<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
h1, h2, h3, h4, h5 { white-space: pre-wrap; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; border-color: transparent !important; padding-top: 0px !important; padding-bottom: 0px !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  #write > p:nth-child(1) { margin-top: 0px; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
  figure { overflow-x: visible; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; overflow-wrap: anywhere; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }
mjx-container { break-inside: avoid; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
/* cyrillic-ext */
/* cyrillic */
/* greek-ext */
/* greek */
/* vietnamese */
/* latin-ext */
/* latin */
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 600;
    src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('file:///C://Users//ASUS//AppData//Roaming//Typora/themes/vue/6xKydSBYKcSV-LCoeQqfX1RYOo3i54rwlxdu.woff2') format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}@import '';

:root {
    --side-bar-bg-color: #1d1d1d;
    --control-text-color: #aaaaaa;
    --select-text-bg-color: hsl(153, 47%, 40%);
    --active-file-bg-color:  hsl(153, 47%, 40%);
    --select-text-font-color: #aaaaaa;
    --active-file-text-color: #eeeeee;
    --search-select-bg-color: #13c172;
    --search-select-text-color: #000;
    --bg-color: #1d1d1d;
    --item-hover-bg-color: var(--select-text-bg-color);
    --text-color: #aaaaaa;
    --font-sans-serif: 'Source Sans Pro', sans-serif !important;
    --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important;
}

.md-rawblock-control:not(.md-rawblock-tooltip) {
    background: #555;
    color: #eeeeee;
}

.md-rawblock-on-edit>.md-rawblock-tooltip, .md-rawblock:hover>.md-rawblock-container, .md-rawblock:hover>.md-rawblock-tooltip {
    background: #555;
    color: #eeeeee;
}

/* code color */
.cm-s-inner .cm-keyword {
    color: #bb7fc3
}

.cm-s-inner .cm-atom, .cm-s-inner.cm-atom {
    color: #9088cc
}

.cm-s-inner .cm-number {
    color: #88b2a1
}

.cm-s-inner .cm-def {
    color: #7f7fff
}

.cm-s-inner .cm-variable {
    color: #efefef
}

.cm-s-inner .cm-variable-2 {
    color: #7faad4
}

.cm-s-inner .cm-variable-3 {
    color: #7fc3aa
}

.cm-s-inner .cm-string {
    color: #d48888
}

.cm-s-inner .cm-property {
    color: #efefef
}

.cm-s-inner .cm-operator {
    color: #cb8c8c
}

.cm-s-inner .cm-comment, .cm-s-inner.cm-comment {
    color: hsl(0, 0%, 35%)
}

.cm-s-inner .cm-string-2 {
    color: #ffaa7f
}

.cm-s-inner .cm-meta {
    color: hsl(0, 0%, 33%)
}

.cm-s-inner .cm-qualifier {
    color: hsl(0, 0%, 33%)
}

.cm-s-inner .cm-builtin {
    color: #997fd4
}

.cm-s-inner .cm-bracket {
    color: #ccccbb
}

.cm-s-inner .cm-tag {
    color: #88bb7f
}

.cm-s-inner .cm-attribute {
    color: #7f7fe5
}

.cm-s-inner .cm-header, .cm-s-inner.cm-header {
    color: #7f7fff
}

.cm-s-inner .cm-quote, .cm-s-inner.cm-quote {
    color: #7fcc7f
}

.cm-s-inner .cm-hr, .cm-s-inner.cm-hr {
    color: hsl(0, 0%, 60%)
}

.cm-s-inner .cm-link, .cm-s-inner.cm-link {
    color: #7f7fe5
}

.cm-negative {
    color: #eea1a1
}

.cm-positive {
    color: #90cc90
}

.cm-header, .cm-strong {
    font-weight: 700
}

.cm-error {
    color: #ff7f7f
}

.cm-invalidchar {
    color: #ff7f7f
}

.cm-constant {
    color: #42b983
}

.cm-defined {
    color: #dac37f
}

div.CodeMirror span.CodeMirror-matchingbracket {
    color: #7fff7f
}

div.CodeMirror span.CodeMirror-nonmatchingbracket {
    color: #ff9090
}

.info-panel-tab:hover {
    color:  #42b983;
}

.outline-label:hover {
    text-decoration: none;
}

input {
    color: #42b983;
}

.info-panel-tab:hover {
    color:  #42b983;
}

.outline-label:hover {
    text-decoration: none;
}

input {
    color: #42b983;
}

.dropdown-menu>li>a:focus, .dropdown-menu>li>a:hover {
    background: var(--select-text-bg-color);
    color: #fff;
}

html {
    font-size: 16px;
}

body {
    font-family: var(--font-sans-serif);
    color: #eeeeee;
    background-color: #1f1f1f;
    -webkit-font-smoothing: antialiased;
    line-height: 1.6rem;
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
}

#write {
    max-width: 860px;
    margin: 0 auto;
    padding: 20px 30px 40px 30px;
    padding-top: 20px;
    padding-bottom: 100px;
}

#write p {
    /* text-indent: 2rem; */
    line-height: 1.6rem;
    word-spacing: .05rem;
}

#write ol li {
    padding-left: 0.5rem;
}

#write > ul:first-child,
#write > ol:first-child {
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}

a {
    color: #42b983;
    font-weight: 600;
    padding: 0px 2px;
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}

h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}

h1 tt,
h1 code {
    font-size: inherit;
}

h2 tt,
h2 code {
    font-size: inherit;
}

h3 tt,
h3 code {
    font-size: inherit;
}

h4 tt,
h4 code {
    font-size: inherit;
}

h5 tt,
h5 code {
    font-size: inherit;
}

h6 tt,
h6 code {
    font-size: inherit;
}

h1 {
    padding-bottom: .4rem;
    font-size: 2.2rem;
    line-height: 1.3;
}

h2 {
    font-size: 1.75rem;
    line-height: 1.225;
    margin: 35px 0px 15px 0px;
    padding-bottom: 0.5em;
    border-bottom: 2px solid hsl(0, 0%, 20%);
}

h3 {
    font-size: 1.4rem;
    line-height: 1.43;
    margin: 20px 0px 7px 0px;
}

h4 {
    font-size: 1.2rem;
}

h5 {
    font-size: 1rem;
}

h6 {
    font-size: 1rem;
    color: hsl(0, 0%, 53%);
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: hsl(0, 0%, 18%);
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

blockquote {
    border-left: 4px solid #42b983;
    padding: 10px 0px 10px 15px;
    color: #eeeeee;
    background-color: rgba(66, 185, 131, .1);
}

table {
    font-family: var(--font-monospace);
    font-size: 0.85rem;
    padding: 0;
    overflow: hidden;
    word-break: initial;
}

table tr {
    border-top: 1px solid hsl(210, 10%, 11%);
    margin: 0;
    padding: 0;
}

table tr:nth-child(2n),
thead {
    /* background-color: hsl(0, 0%, 2%); */
    background-color: hsl(0, 0%, 10%);
}

table tr th {
    font-weight: bold;
    /* border: 1px solid hsl(210, 10%, 11%); */
    border: transparent;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr td {
    /* border: 2px solid hsl(210, 10%, 11%); */
    /* border: 2px solid hsl(0, 0%, 4%); */
    border: 2px solid #1d1d1d;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

#write table thead th {
    /* background-color: hsl(0, 0%, 5%); */
    background-color: hsl(0, 0%, 9%);
}

#write .CodeMirror-gutters {
    border-right: none;
}

#write .md-fences {
    border: 1px solid hsl(0, 0%, 11%);
    -webkit-font-smoothing: initial;
    margin: 0.8rem 0 !important;
    padding: 0.3rem 0rem !important;
    line-height: 1.43rem;
    color: hsl(0, 0%, 78%);
    background-color: hsl(0, 0%, 10%) !important;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-weight: bold;
    font-size: 0.85rem;
    word-wrap: normal;
}

#write .CodeMirror-wrap .CodeMirror-code pre {
    padding-left: 12px;
}

#write code, tt {
    padding: 2px 4px;
    border-radius: 2px;
    font-family: var(--font-monospace);
    font-weight: bold;
    font-size: 0.85rem;
    color: #f3b37f;
    background-color: hsla(0, 0%, 0%, 0.2);
}

tt {
    margin: 0 2px;
}

#write .md-footnote {
    background-color: hsla(0, 0%, 0%, 0.2);
    color: #f3b37f;
}

/* heighlight. */
#write mark {
    background-color: #EBFFEB;
    border-radius: 2px;
    padding: 2px 4px;
    margin: 0 2px;
    color: #222;
    font-weight: 500;
}

#write del {
    padding: 1px 2px;
}

.cm-s-inner .cm-link,
.cm-s-inner.cm-link {
    color: #22a2c9;
}

.cm-s-inner .cm-string {
    color: #22a2c9;
}

.md-task-list-item > input {
    margin-left: -1.3em;
}

@media screen and (min-width: 914px) {
    /*body {
        width: 854px;
        margin: 0 auto;
    }*/
}

@media print {
    html {
        font-size: 13px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: hsl(0, 0%, 3%);
    border: 0;
    border-radius: 3px;
    color: hsl(0, 0%, 53%);
    margin-top: 0 !important;
}

.mathjax-block > .code-tooltip {
    bottom: .375rem;
}

#write > h3.md-focus:before {
    left: -1.5625rem;
    top: .375rem;
}

#write > h4.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h5.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

#write > h6.md-focus:before {
    left: -1.5625rem;
    top: .285714286rem;
}

.md-image > .md-meta {
    border-radius: 3px;
    font-family: var(--font-monospace);
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: inherit;
}

.md-toc {
    margin-top: 20px;
    padding-bottom: 20px;
}

.md-diagram-panel {
    position: static !important;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: hsl(0, 0%, 2%);
    border-color: hsl(0, 0%, 0%) hsl(0, 0%, 10%) hsl(0, 0%, 10%) hsl(0, 0%, 7%);
    border-style: solid;
    border-width: 1px;
}

#md-notification:before {
    top: 10px;
}

/** focus mode */

.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header,
.context-menu,
.megamenu-content,
footer {
    font-family: var(--font-sans-serif);
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state {
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: hsl(0, 0%, 2%);
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #42b983;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: hsl(215, 92%, 5%);
}

#typora-sidebar {
    font-family: var(--font-sans-serif);
    font-weight: bold;
}

.file-list-item-summary{
    font-family: var(--font-sans-serif);
    font-weight: 400;
}

.file-list-item {
    border-bottom: 0.15rem solid hsl(0, 0%, 18%);
}

.file-list-item.active {
    background: hsl(0, 0%, 15%) !important;
}

.file-node-background {
    height: 29px;
}

#toc-dropmenu {
    background: hsl(0, 0%, 18%) !important;
    font-weight: bold;
}

#toc-content {
    margin-top: 1.0rem;
    margin-bottom: 1.0rem;
}

#toc-content a:hover {
    text-decoration: none;
}

.outline-item {
    /* transition: color 150ms, background-color 150ms; */
    transition: color 150ms;
}

.outline-item:hover {
    background-color: rgba(0, 0, 0, 0.5);
    color: #42b983;
}

.sidebar-footer {
    border-top: 2px solid hsl(0, 0%, 15%) !important;
}

.footer-item:hover, .sidebar-footer-item:hover {
    background-color: rgba(0, 0, 0, 0.5) !important;
}

.file-tree-node.active>.file-node-background {
    background-color: hsl(0, 0%, 15%) !important;
}

.file-node-content:hover {
    color: #eeeeee;
}

html{
    background: #1f1f1f !important;
}

.outline-title-wrapper {
    display: none;
}

.dropdown-menu .divider {
    display: none;
    height: 2px;
    background-color: hsl(0, 0%, 13%);
}

.dropdown-menu>li>a {
    color: #eeeeee;
}

.autoComplt-hint {
    color: #42b983 !important;
    /* border-color: transparent !important */
}

.auto-suggest-container {
    color: #42b983 !important;
    font-family: var(--font-sans-serif);
    font-weight: bold !important;
    border-color: #42b983 !important;
    border-radius: 8px !important;
    border-width: 2px !important;
    margin-top: 5px;
    overflow: hidden !important;
    box-shadow: 0 0 1rem hsla(153, 47%, 49%, 0.3);
}

/* .auto-suggest-container li { */
    /* transition: all 150ms; */
    /* text-align: center !important; */
/* } */

.auto-suggest-container li:hover {
    color: #eeeeee !important;
    background-color: #42b983 !important;
    /* text-align: right !important; */
}

/* windows */
/* .modal-dialog { */
    /* color: #000; */
/* } */

.typora-sourceview-on #toggle-sourceview-btn{
    background-color: #42b983
}

/* cursor */
.CodeMirror.cm-s-typora-default div.CodeMirror-cursor {
    border-left: 5px solid #42b983;
}

.CodeMirror div.CodeMirror-cursor {
    border-left: 5px solid #42b983;
    z-index: 3;
}

/* selected text */
/* .CodeMirror-selecte { */
    /* background-color: hsla(153, 47%, 49%, 0.5) !important; */
    /* color: #eeeeee !important; */
/* } */

.ty-preferences {
    color: #aaaaaa;
}

.ty-preferences .btn-default:not([disabled]):hover {
    background-color: var(--active-file-bg-color);
    background-image: none;
    color: #fff;
}

.ty-preferences .search-hit {
    background: var(--select-text-bg-color)
}

::-webkit-scrollbar-thumb {
    background: #ffffff35;
}

::-webkit-scrollbar-thumb:active {
    background: #ffffff65;
}



</style><title></title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><h3 id='数据结构上机作业'><em><span>数据结构上机作业</span></em></h3><h4 id='1-第一次作业'><span>1. 第一次作业：</span></h4><h5 id='1）实现冒泡排序'><em><span>（1**）、实现冒泡排序</span></em></h5><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image002.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded md-focus" spellcheck="false" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap CodeMirror-focused" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 78.0625px; left: 183.391px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="" style="position: relative;"><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">#include&lt;stdio.h&gt;</span></pre></div><div class="" style="position: relative;"><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> #include&lt;stdbool.h&gt;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> #define ARR_LEN 255 /***数组长度上限\*/</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> void bubbleSort(int arr[],int len)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; int i,j,temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; _Bool exchanged = true;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; */\*exchanged**值为true**才有必要执行循环，否则值为false**不执行循环\*/*</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; for(i=0; exchanged &amp;&amp; i&lt;len-1; i++) </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  exchanged = false;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  for(j=0; j&lt;len-i-1; j++)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  if (arr[j]&gt;arr[j+1])</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  temp = arr[j];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[j] = arr[j+1];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  arr[j+1] = temp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  exchanged = true; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; } </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> } </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> int main(void){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; int arr[ARR_LEN]={3,5,1,-7,4,9,-6,8,10,4};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; int len=10; *// int len=sizeof(len)/sizeof(arr[0])*</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; int i;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; bubbleSort(arr,len);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; for(i=0;i&lt;len;i++)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  printf("%d\t",arr[i]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; putchar('\n');</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; return 0;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> } </span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 892px;"></div><div class="CodeMirror-gutters" style="display: none; height: 892px;"></div></div></div></pre><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image004.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h5 id='2）实现选择排序'><em><span>（2**）、实现选择排序</span></em></h5><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image006.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span>
<span> void swap(int *a,int *b){</span>
<span>   int temp = *a;</span>
<span>   *a = *b;</span>
<span>   *b = temp;</span>
<span> }</span>
<span> void selectionSort(int arr[],int len){</span>
<span> </span><br/><span>   for(int i=0;i&lt;len-1;i++){</span>
<span>    int min = i;</span>
<span>  </span><br/><span>    for(int j=i+1;j&lt;len;j++){</span>
<span>      if(arr[j]&lt;arr[min]){</span>
<span>        min = j;</span>
<span>      }</span>
<span>    }</span>
<span>    swap(&amp;arr[min],&amp;arr[i]);</span>
<span>   }</span>
<span> }</span>
<span> </span>
<span> int main(){</span>
<span>   int arr[]={15,65,2,6,14,74,25,3,26,1,4,5,11,97};</span>
<span>   int len = sizeof(arr)/sizeof(arr[0]);</span>
<span>   selectionSort(arr,len);</span>
<span>   for(int i=0;i&lt;len;i++)</span>
<span>    printf(&quot;%d\t&quot;,arr[i]);</span>
<span>   putchar(&#39;\n&#39;);</span>
<span> </span><br/><span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image008.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h4 id='2第二次作业'><span>2、第二次作业：</span></h4><p><span>*</span><strong><span>/</span><span>*</span></strong><strong><span>有问题*</span></strong><strong><span>/(1)</span><span>*</span></strong><span> *</span><strong><span>实现顺序表的基本操作：初始化顺序表、插入数据建顺序表、删除、按值查找</span><span>*</span></strong></p><p><span> </span><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span><span>#</span><span>define Volume 29</span>
<span> typedef struct{</span>
<span>   int *data;</span>
<span>   int length;</span>
<span>   int capacity; </span><em><span>//**容量</span></em><span> </span>
<span> }SqList;</span>
<span> </span>
<span> void InitList(SqList </span><em><span>L){</span>
<span>   L-&gt;data = (int</span></em><span>)malloc(Volume*sizeof(int));</span>
<span>   if(!L-&gt;data){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    exit(1);</span>
<span>   }</span>
<span>   for(int i=0;i&lt;Volume;i++)</span>
<span>    L-&gt;data[i]=0;</span>
<span>   L-&gt;length=0;</span>
<span>   L-&gt;capacity=Volume;</span>
<span> }</span>
<span> </span>
<span> void InsertList(SqList *L,int index,int elem){</span>
<span>   if(index&lt;0 || index &gt; L-&gt;length){</span>
<span>    printf(&quot;超出范围\n&quot;);</span>
<span>    return ;</span>
<span>   }</span>
<span>   if(L-&gt;length &gt;= L-&gt;capacity){</span>
<span>    printf(&quot;容量已满\n&quot;);</span>
<span>    return ;</span>
<span>   }</span>
<span>   for(int i=L-&gt;length;i&gt;index;i--)</span>
<span>    L-&gt;data[i] = L-&gt;data[i-1];</span>
<span>   L-&gt;data[index]=elem;</span>
<span>   L-&gt;length++;</span>
<span> }</span>
<span> </span>
<span> void DeleteList(SqList *L,int index,int *elem){</span>
<span>   if(index&lt;0 || index&gt;=L-&gt;capacity){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    exit(1);</span>
<span>   }</span>
<span>   </span><em><span>//</span><strong><span>指针p</span></strong><span>指向被删除元素的位置</span></em><span> </span>
<span>   int *p = &amp;(L-&gt;data[index]);</span>
<span>   </span><em><span>//**被删除的元素赋值给elem</span></em>
<span>   *elem = *p; </span>
<span>   </span><em><span>//**被删元素之后的元素左移</span></em><span> </span>
<span>   for(int i=index;i</span><L-><span>length;i++){</span>
<span>    L-&gt;data[i]=L-&gt;data[i+1];</span>
<span>   }</span>
<span>   L-&gt;length--;</span>
<span> }</span>
<span> </span>
<span> int Find_by_Index(SqList *L,int index){</span>
<span>   if(index&lt;0 || index&gt;L-&gt;length){</span>
<span>    printf(&quot;查无此数.\n&quot;);</span>
<span>    exit(1);</span>
<span>   }</span>
<span>   int result = L-&gt;data[index];</span>
<span>   return result;</span><br/><span> } </span>
<span> </span>
<span> void Find_by_Value(SqList *L,int value){</span>
<span>   _Bool exchanged = true;</span>
<span>   for(int i=0;i</span><L-><span>length;i++){</span>
<span>    exchanged = false;</span>
<span>    if(value == L-&gt;data[i]){</span>
<span>      printf(&quot;数值为%d的元素的索引为%d\n&quot;,value,i+1);</span>
<span>      exchanged = true;</span>
<span>    }</span>
<span>   }</span>
<span>   if(!exchanged)</span>
<span>    printf(&quot;查无此数.\n&quot;);</span>
<span> }</span>
<span> </span>
<span> int main(){</span>
<span>   SqList L; </span>
<span>   </span><em><span>//**初始化</span></em><span> </span>
<span>   InitList(&amp;L);</span>
<span>   printf(&quot;初始化结果：\n&quot;);</span>
<span>   for(int i=0;i&lt;L.capacity;i++){</span>
<span>    L.data[i]=i;</span>
<span>    L.length++;</span>
<span>    printf(&quot;%d &quot;,L.data[i]);</span>
<span>   }</span>
<span>   putchar(&#39;\n&#39;);</span>
<span>   </span><em><span>//**插入元素</span></em>
<span>   putchar(&#39;\n&#39;);</span>
<span>   printf(&quot;插入元素结果：\n&quot;);</span>
<span>   for(int i=3;i&lt;17;i+=2)</span>
<span>    L.data[i] = (-2)*i+42;</span>
<span>   for(int i=0;i&lt;L.length;i++)</span>
<span>    printf(&quot;%d &quot;,L.data[i]);</span>
<span>   putchar(&#39;\n&#39;);</span>
<span>   </span><em><span>//**删除元素</span></em>
<span>   putchar(&#39;\n&#39;);</span>
<span>   int elem=0;</span>
<span>   DeleteList(&amp;L,7,&amp;elem);</span>
<span>   printf(&quot;被删除的元素是：%d\n&quot;,elem);</span>
<span>   printf(&quot;删除元素结果：\n&quot;);</span>
<span>   for(int i=0;i&lt;L.length;i++)</span>
<span>    printf(&quot;%d &quot;,L.data[i]);</span>
<span>   putchar(&#39;\n&#39;);</span>
<span>   </span><em><span>//**按位查找</span></em><span> </span>
<span>   putchar(&#39;\n&#39;);</span>
<span>   for(int i=3;i&lt;12;i+=2){</span>
<span>    printf(&quot;第%d位数值是：%d   &quot;,i,Find_by_Index(&amp;L,i));</span>
<span>   }</span>
<span>   putchar(&#39;\n&#39;);</span>
<span>   </span><em><span>//**按值查询</span></em>
<span>   putchar(&#39;\n&#39;);</span>
<span>   Find_by_Value(&amp;L,7);</span>
<span>   Find_by_Value(&amp;L,12);</span>
<span>   Find_by_Value(&amp;L,17);</span>
<span>   Find_by_Value(&amp;L,29);</span>
<span>   putchar(&#39;\n&#39;);</span>
<span> </span><br/><span>   free(L.data);</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image010.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(2)</span><span>*</span></strong><span> </span><em><strong><span>设计一个高效的算法，将顺序表的所有元素逆置，要求算法的空间复杂度为</span><span>*</span></strong><span>**</span></em><span>O</span><span>*</span><strong><span>*</span></strong><span>（</span><span>*</span><strong><span>*</span></strong><span>1</span><span>*</span><strong><span>*</span></strong><span>）。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span>
<span> typedef struct {</span>
<span>   int *data;</span>
<span>   int length;</span>
<span> } SqList;</span>
<span> </span>
<span> void InitList(SqList </span><em><span>L, int length) {</span>
<span>   L-&gt;data = (int</span></em><span>)malloc(length * sizeof(int));</span>
<span>   if (!L-&gt;data) {</span>
<span>     printf(&quot;Error.\n&quot;);</span>
<span>     exit(1);</span>
<span>   }</span>
<span>   L-&gt;length = length;</span>
<span>   for (int i = 0; i &lt; L-&gt;length; i++)</span>
<span>     L-&gt;data[i] = i;</span>
<span> }</span>
<span> </span>
<span> void Reversal(SqList *L, int length) {</span>
<span>   int *start = &amp;L-&gt;data[0];</span>
<span>   int *end = &amp;L-&gt;data[length - 1];</span>
<span>   while (</span>
<span>   </span><br/><span>     start &lt; end) {</span>
<span>     </span><em><span>//</span></em><span> </span><em><span>倒置</span></em>
<span>     int temp = *start;</span>
<span>     *start = *end;</span>
<span>     *end = temp;</span>
<span>     </span><em><span>//</span></em><span> </span><em><span>移动指针</span></em>
<span>     start++;</span>
<span>     end--;</span>
<span>   }</span>
<span> }</span>
<span> </span>
<span> int main() {</span>
<span>   SqList L;</span>
<span>   InitList(&amp;L, 30);</span>
<span>   printf(&quot;原排列为：\n&quot;);</span>
<span>   for (int i = 0; i &lt; L.length; i++)</span>
<span>     printf(&quot;%d &quot;, L.data[i]);</span>
<span>   putchar(&#39;\n&#39;);</span>
<span>   Reversal(&amp;L, 30);</span>
<span>   printf(&quot;倒置结果为：\n&quot;);</span>
<span>   for (int i = 0; i &lt; L.length; i++)</span>
<span>     printf(&quot;%d &quot;, L.data[i]);</span>
<span>   free(L.data);</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image012.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(3)</span><span>*</span></strong><span> </span><em><strong><span>长度为</span><span>*</span></strong><span>**</span></em><span>n</span><span>*</span><strong><span>*</span></strong><span>的顺序表</span><span>*</span><strong><span>*</span></strong><span>L</span><span>*</span><strong><span>*</span></strong><span>，编写一个时间复杂度为</span><span>*</span><strong><span>*</span></strong><span>O</span><span>*</span><strong><span>*</span></strong><span>（</span><span>*</span><strong><span>*</span></strong><span>n</span><span>*</span><strong><span>*</span></strong><span>）、空间复杂度为</span><span>*</span><strong><span>*</span></strong><span>O</span><span>*</span><strong><span>*</span></strong><span>（</span><span>*</span><strong><span>*</span></strong><span>1</span><span>*</span><strong><span>*</span></strong><span>）的算法，该算法删除线性表中所有值为</span><span>*</span><strong><span>*</span></strong><span>x</span><span>*</span><strong><span>*</span></strong><span>的数据元素。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> typedef struct{</span>
<span>   int *data;</span>
<span>   int length;</span>
<span> }SqList;</span>
<span> </span>
<span> void InitList(SqList </span><em><span>L,int n){</span>
<span>   L-&gt;data=(int</span></em><span>)malloc(n*sizeof(int));</span>
<span>   if(!L-&gt;data){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    exit(1);</span>
<span>   }</span>
<span>   L-&gt;length=n;</span>
<span>   for(int i=0;i</span><L-><span>length;i++){</span>
<span>    L-&gt;data[i]=i+1;</span>
<span>   }</span>
<span> }</span>
<span> </span>
<span> bool Remove(SqList *L,int x){</span>
<span>   int count=0; </span><em><span>//</span><strong><span>用于数值等于x</span></strong><span>的元素个数计数</span></em>
<span>   int i=0;</span>
<span>   while(i</span><L-><span>length){</span>
<span>    if(L-&gt;data[i]==x){</span>
<span>      count++;</span>
<span>    }</span>
<span>    else{</span>
<span>      L-&gt;data[i-count]=L-&gt;data[i];  </span><br/><span>    }</span>
<span>    i++;</span>
<span>   } </span>
<span>   L-&gt;length=L-&gt;length-count;</span>
<span>   if(count!=0)</span>
<span>    return true;</span>
<span>   else</span>
<span>    return false;</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   SqList L;</span>
<span>   </span><em><span>//**初始化</span></em><span> </span>
<span>   InitList(&amp;L,25);</span>
<span>   for(int i=0;i&lt;L.length;i++){</span>
<span>    printf(&quot;%d &quot;,L.data[i]);</span>
<span>   }</span>
<span>   </span><em><span>//**删除</span></em>
<span>   printf(&quot;\n删除后：\n&quot;); </span>
<span>   Remove(&amp;L,11);</span>
<span>   for(int i=0;i&lt;L.length;i++){</span>
<span>    printf(&quot;%d &quot;,L.data[i]);</span>
<span>   }</span>
<span>   free(L.data);</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image014.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h4 id='3第三次作业'><span>3、第三次作业：</span></h4><p><span>*</span><strong><span>(1)</span><span>*</span></strong><span> *</span><strong><span>实现带头节点链表的基本操作：初始化链表、头插法建链表、尾插法建链表、插入、删除、按值查找</span><span>*</span></strong></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>/</span><span>*</span><span>LNode</span><strong><span>表示是个结点,LinkList</span></strong><span>表示链表</span><span>*</span><span>/</span></em>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LinkList</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=0;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**头插法建链表</span></em><span> </span>
<span> LinkList HeadInsert(LinkList L){</span>
<span>   if(!L){</span>
<span>    return L; </span>
<span>   }</span>
<span>   LNode *head=L; </span><em><span>//**头结点</span></em><span> </span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以0为结束):&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span>   while(x!=0){</span>
<span>    new=(LinkList</span></em><span>)malloc(sizeof(LNode));</span>
<span>    if(!new){</span>
<span>      return L;</span>
<span>    }</span>
<span>    new-&gt;data = x;</span>
<span>    new-&gt;next = head-&gt;next;</span>
<span>    head-&gt;next = new;</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>   }</span>
<span>   return L;</span>
<span> } </span>
<span> </span><em><span>//**尾插法建链表</span></em><span> </span>
<span> LinkList TailInsert(LinkList L){</span>
<span>   if(!L){</span>
<span>    return L;</span>
<span>   }</span>
<span>   LNode *tail=L; </span><em><span>//**用于追踪链表尾部</span></em><span> </span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以0结束)：&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span>   while(x!=0){</span>
<span>    new=(LinkList</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L;</span>
<span> } </span>
<span> </span><em><span>//**获得长度</span></em>
<span> int Length(LinkList L){</span>
<span>   int len=0;</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p){</span>
<span>    p = p-&gt;next;</span>
<span>    len++;</span>
<span>   }</span>
<span>   return len;</span>
<span> } </span>
<span> </span><em><span>//(</span><strong><span>带头结点)</span></strong><span>插入</span></em>
<span> bool Insert(LinkList L,int index,int elem){</span>
<span>   if(index&lt;0||index&gt;Length(L)){</span>
<span>    printf(&quot;超出范围.\n&quot;);</span>
<span>    return ;</span>
<span>   }</span>
<span>   LNode </span><em><span>s,</span></em><span>p=L;</span>
<span>   int j=0;</span>
<span>   while(p &amp;&amp; j&lt;index-1){</span>
<span>    p = p-&gt;next;</span>
<span>    ++j;</span>
<span>   }</span>
<span>   s=(LinkList*)malloc(sizeof(LNode));</span>
<span>   s-&gt;data = elem;</span>
<span>   s-&gt;next = p-&gt;next; </span><em><span>//</span><strong><span>插入L</span></strong><span>中</span></em>
<span>   p-&gt;next = s;</span>
<span> </span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//(</span><strong><span>带头结点)</span></strong><span>删除</span></em>
<span> bool Remove(LinkList L,int index){</span>
<span>   if(index&lt;1 || index&gt;Length(L)){</span>
<span>    printf(&quot;超出范围.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   LNode *p=L;</span>
<span>   int j=0;</span>
<span>   while(p &amp;&amp; j&lt;index-1){</span>
<span>    p = p-&gt;next;</span>
<span>    ++j;</span>
<span>   }</span>
<span>   if(p-&gt;next==NULL){</span>
<span>    return false;</span>
<span>   }</span>
<span>   LNode *q = p-&gt;next;</span>
<span>   p-&gt;next = q-&gt;next;</span>
<span>   free(q);</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**按值查找</span></em>
<span> LNode *FindElem(LinkList L,ElemType elem){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p &amp;&amp; p-&gt;data!= elem){</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   return p;</span>
<span> }</span>
<span> </span><em><span>//**遍历链表</span></em>
<span> void Print(LinkList L){</span>
<span>   LNode *p=L-&gt;next;</span>
<span>   if(p==NULL) </span>
<span>    printf(&quot;\n这是空链表.\n&quot;);</span>
<span>   else{</span>
<span>    printf(&quot;\n链表为:&quot;);</span>
<span>    while(p!=NULL){</span>
<span>      printf(&quot;%d &quot;,p-&gt;data);</span>
<span>      p = p-&gt;next;</span>
<span>    }</span>
<span>    printf(&quot;\n&quot;);</span>
<span>   }</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   </span><em><span>//**初始化</span></em><span> </span>
<span>   InitList(&amp;L);</span>
<span>   printf(&quot;操作开始：\n&quot;);</span>
<span>   </span><em><span>//**头插法</span></em><span> </span>
<span>   printf(&quot;头插法建立链表:\n&quot;);</span>
<span>   HeadInsert(L);</span>
<span>   Print(L);</span>
<span>   </span><em><span>//**尾插法</span></em>
<span>   printf(&quot;\n\n尾插法建立链表:\n&quot;);</span>
<span>   TailInsert(L);</span>
<span>   Print(L); </span>
<span>   </span><em><span>//**插入</span></em>
<span>   printf(&quot;\n插入元素5到链表第2个位置:\n&quot;);</span>
<span>   if(Insert(L, 2, 5)){</span>
<span>     Print(L);</span>
<span>   }</span>
<span>   </span><em><span>//**删除</span></em>
<span>   printf(&quot;\n删除链表第3个位置的元素:\n&quot;);</span>
<span>   if(Remove(L, 3)){</span>
<span>     Print(L);</span>
<span>   }</span>
<span>   </span><em><span>//**查找元素</span></em>
<span>   printf(&quot;\n查找元素10:\n&quot;);</span>
<span>   LNode *found = FindElem(L, 10);</span>
<span>   if(found != NULL){</span>
<span>     printf(&quot;找到元素 %d\n&quot;, found-&gt;data);</span>
<span>   } else {</span>
<span>     printf(&quot;未找到元素\n&quot;);</span>
<span>   }</span>
<span>   </span><em><span>//**释放内存</span></em>
<span>   LNode </span><em><span>p = L,</span></em><span>q;</span>
<span>   while(p!=NULL){</span>
<span>    q = p-&gt;next;</span>
<span>    free(p);</span>
<span>    p = q;</span>
<span>   } </span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image016.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(2)</span><span>*</span></strong><span> </span><em><strong><span>在带头结点的单链表</span><span>*</span></strong><span>**</span></em><span>L</span><span>*</span><strong><span>*</span></strong><span>中，删除所有值为</span><span>*</span><strong><span>*</span></strong><span>x</span><span>*</span><strong><span>*</span></strong><span>的节点，并释放其空间，假设值为</span><span>*</span><strong><span>*</span></strong><span>x</span><span>*</span><strong><span>*</span></strong><span>的结点不唯一，试编写算法以实现上述操作。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LinkList</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=0;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**尾插法建链表</span></em>
<span> LinkList TailInsert(LinkList L){</span>
<span>   if(!L){</span>
<span>    return L;</span>
<span>   }</span>
<span>   LNode *tail=L; </span><em><span>//**用于追踪链表尾部</span></em><span> </span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以0结束):&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span>   while(x!=0){</span>
<span>    new=(LinkList</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L;</span>
<span> } </span>
<span> </span><em><span>//</span><strong><span>删除值为x</span></strong><span>的节点</span></em>
<span> void Remove_Elem(LinkList L,ElemType x){</span>
<span>   LNode *p=L-&gt;next;</span>
<span>   while(p-&gt;next != NULL){</span>
<span>    if(p-&gt;next-&gt;data == x){</span>
<span>      LNode *temp = p-&gt;next;</span>
<span>      p-&gt;next = temp-&gt;next; </span><em><span>//**跳过要删除的节点</span></em>
<span>      free(temp); </span><em><span>//**释放节点空间</span></em><span> </span>
<span>    }</span>
<span>    else{</span>
<span>      p = p-&gt;next; </span>
<span>    }</span>
<span>   }</span>
<span> }</span>
<span> </span><em><span>//**打印链表</span></em>
<span> void PrintList(LinkList L){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p != NULL){</span>
<span>    printf(&quot;%d &quot;,p-&gt;data);</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   printf(&quot;\n&quot;);</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   ElemType x;</span>
<span>   printf(&quot;请输入元素x的值：\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span> </span><br/><span>   InitList(&amp;L);</span>
<span>   TailInsert(L);</span>
<span>   Remove_Elem(L,x);</span>
<span>   PrintList(L);</span>
<span> </span><br/><span>   </span><em><span>//</span></em><span> </span><em><span>释放链表占用的内存</span></em>
<span>   LNode *p = L, *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image018.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(3)</span><span>*</span></strong><span> </span><em><strong><span>试</span><span>*</span></strong><span>**</span></em><span>L</span><span>*</span><strong><span>*</span></strong><span>为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LinkList</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=NULL;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> }</span>
<span> </span><em><span>//**尾插法</span></em>
<span> LinkList TailList(LinkList L){</span>
<span>   if(!L){</span>
<span>    return L;</span>
<span>   } </span>
<span>   LNode *tail=L;</span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以0结束):\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span>   while(x!=0){</span>
<span>    new=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>   } </span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L;</span>
<span> } </span>
<span> </span><em><span>//**反向输出</span></em>
<span> void Reverse_Print(LinkList L){</span>
<span>   if(L-&gt;next != NULL){</span>
<span>    Reverse_Print(L-&gt;next);</span>
<span>   }</span>
<span>   printf(&quot;%d-&gt;&quot;,L-&gt;data);</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   InitList(&amp;L);</span>
<span>   TailList(L);</span>
<span>   Reverse_Print(L);</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>释放链表占用的内存</span></em>
<span>   LNode *p = L, *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image020.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(4)</span><span>*</span></strong><span> </span><em><strong><span>试编写在带头结点的单链表</span><span>*</span></strong><span>**</span></em><span>L</span><span>*</span><strong><span>*</span></strong><span>中删除一个最小值结点的高效算法（假设最小值结点是唯一的）。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=0;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**尾插法</span></em>
<span> LinkList TailList(LinkList L){</span>
<span>   if(!L){</span>
<span>    return NULL;</span>
<span>   }</span>
<span>   LNode *tail=L;</span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以0结束)：\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span>   while(x!=0){</span>
<span>    new=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L;</span>
<span> } </span>
<span> </span><em><span>//**删除最小</span></em>
<span> void Delete_Min(LinkList L){</span>
<span>   if(L==NULL || L-&gt;next==NULL){</span>
<span>    return;</span>
<span>   }</span>
<span>   LNode *p=L-&gt;next; </span><em><span>//**第一个实际结点</span></em>
<span>   LNode </span><em><span>pre=L;</span></em><span>//pre</span><strong><span>用于指向最小值结点的前一个*</span>
<span>   LNode *min=p; *//</span></strong><span>用于表示最小值的结点*</span>
<span>   while(p != NULL &amp;&amp; p-&gt;next!=NULL){</span>
<span>    if(p-&gt;next-&gt;data &lt; min-&gt;data){</span>
<span>      pre=p;</span>
<span>      min=p-&gt;next;</span>
<span>    }</span>
<span>    p=p-&gt;next;</span>
<span>   }</span>
<span>   </span><em><span>//**最小值是第一个节点</span></em>
<span>   if(min==L-&gt;next){</span>
<span>    pre-&gt;next = min-&gt;next;</span>
<span>   } </span><em><span>//**最小值在末尾或中间</span></em><span> </span>
<span>   else{</span>
<span>    pre-&gt;next = min-&gt;next;</span>
<span>    free(min); </span>
<span>   } </span>
<span> } </span>
<span> </span><em><span>//**打印链表</span></em>
<span> void PrintList(LinkList L){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p != NULL){</span>
<span>    printf(&quot;%d &quot;,p-&gt;data);</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   printf(&quot;\n&quot;);</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   InitList(&amp;L);</span>
<span>   TailList(L);</span>
<span>   Delete_Min(L);</span>
<span>   printf(&quot;删除最小值结点后：\n&quot;);</span>
<span>   PrintList(L);</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>释放链表占用的内存</span></em>
<span>   LNode *p = L, *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image022.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(5)</span><span>*</span></strong><span> *</span><strong><span>已知一个带有表头结点的单链表，结点结构为</span><span>*</span></strong></p><p><em><strong><span>假设该链表只给出了头指针</span><span>*</span></strong><span>**</span></em><span>list</span><span>*</span><strong><span>*</span></strong><span>，在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第</span><span>*</span><strong><span>*</span></strong><span>k</span><span>*</span><strong><span>*</span></strong><span>个位置上的结点（</span><span>*</span><strong><span>*</span></strong><span>k</span><span>*</span><strong><span>*</span></strong><span>为正整数）。若查找成功，算法输出该结点的</span><span>*</span><strong><span>*</span></strong><span>data</span><span>*</span><strong><span>*</span></strong><span>域的值，并返回</span><span>*</span><strong><span>*</span></strong><span>1</span><span>*</span><strong><span>*</span></strong><span>；否则，只返回</span><span>*</span><strong><span>*</span></strong><span>0</span><span>*</span><strong><span>*</span></strong><span>。要求：</span><span>*</span><span>**</span></p><p><em><strong><span>1</span><span>*</span></strong><span>**</span></em><span>）描述算法的基本</span><span>*</span><span>** *</span><strong><span>设计思想。</span><span>*</span></strong></p><p><span>创建两个指针&quot;fast&quot;和&quot;slow&quot;，两个指针都先指向头结点。开始操作：让fast移动k步，这样两个指针间就相差了k步。两个指针接着同步移动，直至 fast-&gt;next==NULL。</span></p><p><em><strong><span>2</span><span>*</span></strong><span>**</span></em><span>）描述算法的详细实现步骤</span><span>*</span><span>**</span></p><p><span>创建两个指针&quot;fast&quot;和&quot;slow&quot;，两个指针都先指向头结点。开始操作：让fast移动k步，如果链表长度小于k，那么直接返回0，因为不存在倒数第k个结点。这样两个指针间就相差了k步。两个指针接着同步移动，直至 fast-&gt;next==NULL,slow指针将指向倒数第k个结点。</span>
<span> 输出结果：如果fast指针能够到达链表末尾，那么slow指针指向的就是倒数第k个结点，输出该结点的data域的值，并返回1；如果fast指针在到达链表末尾之前就已经没有下一个结点了，说明链表长度小于k，返回0。</span></p><p><em><strong><span>3</span><span>*</span></strong><span>**</span></em><span>）根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处请给出简要注释。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=0;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**尾插法</span></em>
<span> LinkList TailList(LinkList L){</span>
<span>   if(!L){</span>
<span>    return NULL;</span>
<span>   }</span>
<span>   LNode *tail=L;</span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以0结束):\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;x);</span>
<span>   while(x!=0){</span>
<span>    new=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>    scanf(&quot;%d&quot;,&amp;x); </span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L; </span>
<span> } </span>
<span> </span><em><span>//</span><strong><span>倒数第k</span></strong><span>个</span></em>
<span> int Inverse_Count(LinkList L,int k){</span>
<span>   if(L==NULL || k&lt;=0){</span>
<span>    return 0;</span>
<span>   }</span>
<span>   LNode *fast=L;</span>
<span>   LNode *slow=L;</span>
<span>   </span><em><span>//</span><strong><span>让 fast</span></strong><span>指针先走k**步</span></em>
<span>   for(int i=0;i&lt;k;i++){</span>
<span>    if(fast==NULL)</span>
<span>      return 0;</span>
<span>    fast = fast-&gt;next;</span>
<span>   } </span>
<span>   </span><em><span>//**双指针同步移动</span></em>
<span>   while(fast != NULL){</span>
<span>    fast = fast-&gt;next;</span>
<span>    slow = slow-&gt;next;</span>
<span>   } </span>
<span>   </span><em><span>//</span><strong><span>如果fast</span></strong><span>指针到达末尾，slow</span><strong><span>指向倒数第k</span></strong><span>个</span></em>
<span>   printf(&quot;倒数第%d为:%d\n&quot;,k,slow-&gt;data);</span>
<span>   return 1;</span>
<span> }</span>
<span> </span><em><span>//**打印链表</span></em>
<span> void PrintList(LinkList L){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p != NULL){</span>
<span>    printf(&quot;%d-&gt;&quot;,p-&gt;data);</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   printf(&quot;\n&quot;);</span>
<span> } </span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   InitList(&amp;L);</span>
<span>   TailList(L);</span>
<span>   printf(&quot;链表为：\n&quot;); </span>
<span>   PrintList(L);</span>
<span>   Inverse_Count(L,7);</span>
<span>   PrintList(L);</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>释放链表占用的内存</span></em>
<span>   LNode *p = L, *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image024.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>*</span><strong><span>(6)</span><span>*</span></strong><span> </span><em><strong><span>假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，设</span><span>*</span></strong><span>**</span></em><span>str1</span><span>*</span><strong><span>*</span></strong><span>和</span><span>*</span><strong><span>*</span></strong><span>str2</span><span>*</span><strong><span>*</span></strong><span>分别指向两个单词所在单链表的头结点，链表结点结构为，请设计一个时间上尽可能高效的算法，找出由</span><span>*</span><strong><span>*</span></strong><span>str1</span><span>*</span><strong><span>*</span></strong><span>和</span><span>*</span><strong><span>*</span></strong><span>str2</span><span>*</span><strong><span>*</span></strong><span>所指向两个链表共同后缀的起始位置（如图中字符</span><span>*</span><strong><span>*</span></strong><span>i</span><span>*</span><strong><span>*</span></strong><span>所在结点的位置</span><span>*</span><strong><span>*</span></strong><span>p</span><span>*</span><strong><span>*</span></strong><span>）。要求：</span><span>*</span><span>**</span></p><p><em><strong><span>1</span><span>*</span></strong><span>**</span></em><span>）描述算法的基本设计思想。</span><span>*</span><span>**</span></p><p><span>构造一个函数Length()计算链表的长度，计算出两个链表的长度，并计算它们的差，然后让节点指针指向长度较长的链表并使该指针后移，直到与另一个较短的链表等长，最后让指针同时后移。当两个指针指向同一个地址使，该地址为所寻找的共同后缀的起始位置。</span></p><p><em><strong><span>2</span><span>*</span></strong><span>**</span></em><span>）根据设计思想，采用程序设计语言描述算法，关键之处请给出简要注释。</span><span>*</span><span>**</span></p><p><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span><span>#</span><span>include&lt;math.h&gt;</span>
<span> typedef char ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=&#39;\0&#39;;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**尾插法</span></em>
<span> LinkList TailList(LinkList L){</span>
<span>   if(!L){</span>
<span>    return NULL;</span>
<span>   }</span>
<span>   LNode *tail=L;</span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(以&#39;0&#39;结束):\n&quot;);</span>
<span>   while(scanf(&quot; %c&quot;,&amp;x), x!=&#39;0&#39; &amp;&amp; x!=&#39;\n&#39;){</span>
<span>    new=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L; </span>
<span> } </span>
<span> </span><em><span>//**获得长度</span></em>
<span> int Length(LinkList L){</span>
<span>   int len=0;</span>
<span>   LNode *p = L;</span>
<span>   while(p){</span>
<span>    p = p-&gt;next;</span>
<span>    len++;</span>
<span>   }</span>
<span>   return len;</span>
<span> } </span>
<span> </span><em><span>//**共同后缀</span></em>
<span> LNode* FindCommon(LinkList str1,LinkList str2){</span>
<span>   LNode *p=str1;</span>
<span>   LNode *q=str2;</span>
<span>   int length1 = Length(str1);</span>
<span>   int length2 = Length(str2);</span>
<span>   int distance = abs(length1-length2);</span>
<span>   </span><em><span>//</span><strong><span>若p</span></strong><span>指向的链表长度大于q</span><strong><span>的长度,</span></strong><span>使p**后移</span></em>
<span>   if(length1&gt;length2){</span>
<span>    for(int i=0;i&lt;distance;i++){</span>
<span>      p=p-&gt;next;</span>
<span>    }</span>
<span>   }else{ </span><em><span>//**反之亦然</span></em><span> </span>
<span>    for(int i=0;i&lt;distance;i++){</span>
<span>      q=q-&gt;next;</span>
<span>    }</span>
<span>   }</span>
<span>   while(p &amp;&amp; q &amp;&amp; p-&gt;next-&gt;data != q-&gt;next-&gt;data){</span>
<span>    </span><em><span>//**两个指针同时后移</span></em>
<span>    p=p-&gt;next;</span>
<span>    q=q-&gt;next; </span>
<span>   }</span>
<span>   return p;</span>
<span> }</span>
<span> </span><em><span>//**打印链表</span></em>
<span> void PrintList(LinkList L){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p != NULL){</span>
<span>    printf(&quot;%c-&gt;&quot;,p-&gt;data);</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   printf(&quot;NULL\n&quot;);</span>
<span> } </span>
<span> </span><em><span>//</span></em><span> </span><em><span>释放链表内存</span></em>
<span> void FreeList(LinkList L) {</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   LNode *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   free(L);</span>
<span> }</span>
<span> </span>
<span> int main(){</span>
<span>   LinkList str1,str2;</span>
<span>   </span><em><span>//**初始两个链表</span></em><span> </span>
<span>   InitList(&amp;str1);</span>
<span>   InitList(&amp;str2);</span>
<span>   </span><em><span>//**尾插法</span></em>
<span>   TailList(str1);</span>
<span>   TailList(str2); </span>
<span>   printf(&quot;\n链表str1为:\n&quot;);</span>
<span>   PrintList(str1);</span>
<span>   printf(&quot;\n链表str2为:\n&quot;);</span>
<span>   PrintList(str2);</span>
<span>   </span><em><span>//**共同后缀</span></em>
<span>   LNode* commonSuffix = FindCommon(str1, str2);</span>
<span>   if(commonSuffix){</span>
<span>     printf(&quot;共同后缀为:\n&quot;);</span>
<span>     PrintList(commonSuffix);</span>
<span>   } else {</span>
<span>     printf(&quot;没有共同后缀。\n&quot;);</span>
<span>   }</span>
<span>   </span><em><span>//**释放内存</span></em>
<span>   FreeList(str1);</span>
<span>   FreeList(str2);</span>
<span>  </span><br/><span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image026.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>还有另外一种方法：</span></p><p><span>/**</span>
<span> </span><span>*</span><span> Definition for singly-linked list.</span>
<span> </span><span>*</span><span> struct ListNode {</span>
<span> </span><span>*</span><span>   int val;</span>
<span> </span><span>*</span><span>   struct ListNode *next;</span>
<span> </span><span>*</span><span> };</span>
<span> */</span>
<span> struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {</span>
<span>   if(headA == NULL || headB == NULL){</span>
<span>     return NULL;</span>
<span>   }</span>
<span>   struct ListNode *p = headA, *q = headB;</span>
<span>   while( p != q ){</span>
<span>     p = p == NULL ? headB : p-&gt;next;</span>
<span>     q = q == NULL ? headA : q-&gt;next;</span>
<span>   }</span>
<span>   return p;</span>
<span> }</span></p><p><span> </span></p><p><em><strong><span>3</span><span>*</span></strong><span>**</span></em><span>）说明你所设计算法的时间复杂度</span><span>*</span><span>**</span></p><p><span>1、计算两个链表的长度，Length(str1)和Length(str2)的时间复杂度为 O(n) 。</span>
<span> 2、移动指针使两个链表的起始位置对齐，遍历的时间复杂度为 O(n) 。</span>
<span> 3、对齐后遍历比较，直到找到共同后缀，这部分的时间复杂度为 O(n) 。</span>
<span> 总之，函数的时间复杂度为 O(n) 。</span></p><p><span>*</span><strong><span>(7)</span><span>*</span></strong><span> </span><em><strong><span>用单链表保存</span><span>*</span></strong><span>**</span></em><span>m</span><span>*</span><strong><span>*</span></strong><span>个整数，结点的结构为：</span><span>*</span><strong></strong><span>data</span><strong><span>*</span></strong><span>,</span><span>*</span><strong><span>*</span></strong><span>且</span><span>*</span><strong><span>*</span></strong><span>|data|</span><span>*</span><strong><span>*</span></strong><span>≤</span><span>*</span><strong><span>*</span></strong><span>n(n</span><span>*</span><strong><span>*</span></strong><span>为正整数）。现要求设计一个时间复杂度尽可能高效的算法，对于链表中</span><span>*</span><strong><span>*</span></strong><span>data</span><span>*</span><strong><span>*</span></strong><span>的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</span><span>*</span><span>**</span></p><p><em><strong><span>1</span><span>*</span></strong><span>**</span></em><span>）描述算法的基本</span><span>*</span><span>** *</span><strong><span>设计思想。</span><span>*</span></strong></p><p><span>1、创建一个大小为 m+1 的数组，初始化所有元素为 false。</span>
<span> 2、遍历链表：从头结点开始遍历链表，对于每个结点：</span>
<span>   ●计算结点中 data 的绝对值。</span>
<span>   ●检查出现过数组中对应索引的值：</span>
<span>    如果结点中data的绝对值</span>
<span>    检查出现过数组中对应索引的值：</span>
<span>      如果为false，说明这是第一次遇到这个绝对值，将出现过的数组中对应索引的值设置为true，并保留当前结点。</span>
<span>      如果为true，说明之前已经遇到过这个绝对值，因此需要删除当前结点。</span>
<span> 3、删除结点</span>
<span> 4、处理边界情况：</span>
<span>   ●如果链表为空，直接返回。</span>
<span>   ●在删除结点时，如果当前结点是头结点，需要更新头结点。</span>
<span>   ●在删除结点时，如果当前结点是最后一个结点，需要确保前一个结点的指针被更新。</span>
<span> 5、返回结果</span></p><p><em><strong><span>2</span><span>*</span></strong><span>**</span></em><span>）使用</span><span>*</span><strong><span>*</span></strong><span>C</span><span>*</span><strong><span>*</span></strong><span>或者</span><span>*</span><strong><span>*</span></strong><span>C++</span><span>*</span><strong><span>*</span></strong><span>语言，给出单链表结点的数据类型定义。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span><span>#</span><span>include&lt;math.h&gt;</span>
<span> </span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=0;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**尾插法</span></em>
<span> LinkList TailList(LinkList L,int m){</span>
<span>   if(m&lt;=0){</span>
<span>    return L;</span>
<span>   }</span>
<span>   LNode *tail=L;</span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(元素个数为%d):\n&quot;,m);</span>
<span>   for(int i=0;i&lt;m;i++){</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>    new=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L;</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//**删除重复项</span></em><span> </span>
<span> void Remove(LinkList L,int n){</span>
<span>   if(L==NULL || L-&gt;next==NULL){</span>
<span>    return;</span>
<span>   }</span>
<span>   </span><em><span>//**追踪每个绝对值是否出现过,|data|&lt;=n</span></em><span> </span>
<span>   bool </span><em><span>Lyst=(bool</span></em><span>)malloc((n+1)*sizeof(bool));</span>
<span>   for(int i=0;i&lt;=n;i++){</span>
<span>    Lyst[i]=false;</span>
<span>   }</span>
<span>   </span><em><span>//current</span></em><span> </span><em><span>指针用于遍历链表</span></em><span> </span>
<span>   LNode *current = L-&gt;next;</span>
<span>   </span><em><span>//nextNode</span></em><span> </span><em><span>用于临时存储current**的下一个节点</span></em><span> </span>
<span>   LNode *nextNode;</span>
<span>   </span><em><span>//prev</span></em><span> </span><em><span>用于存储current**的前一个节点</span></em><span> </span>
<span>   LNode *prev = L;</span>
<span> </span>
<span>   while(current != NULL){</span>
<span>    nextNode=current-&gt;next;</span>
<span>    int Value = abs(current-&gt;data);</span>
<span>    </span><em><span>//**检查当前节点的值是否已经出现</span></em>
<span>    if(!Lyst[Value]){ </span>
<span>      </span><em><span>//**标记为</span></em><span> </span><em><span>已出现</span></em><span> </span>
<span>      Lyst[Value]=true;</span>
<span>      prev = current;</span>
<span>      current = nextNode;</span>
<span>    }else{</span>
<span>      </span><em><span>/**</span></em><span>如果已经出现过，删除节点</span><span>*</span><span>/*</span>
<span>      </span><em><span>//</span><strong><span>情况1</span></strong><span>：prev**是头结点</span></em><span> </span>
<span>      if(prev-&gt;next==current){</span>
<span>        prev-&gt;next=nextNode;</span>
<span>        free(current);</span>
<span>        current=nextNode;</span>
<span>      } </span><em><span>//</span><strong><span>情况2</span></strong><span>：prev**不是头结点</span></em><span> </span>
<span>      else{</span>
<span>        prev-&gt;next = nextNode;</span>
<span>        free(current);</span>
<span>        current = prev-&gt;next;</span>
<span>      }</span>
<span>    }</span>
<span>   }</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//**打印链表</span></em>
<span> void PrintList(LinkList L){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p != NULL){</span>
<span>    printf(&quot;%d-&gt;&quot;,p-&gt;data);</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   printf(&quot;NULL\n&quot;);</span>
<span> } </span>
<span> </span><em><span>//</span></em><span> </span><em><span>释放链表内存</span></em>
<span> void FreeList(LinkList L) {</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   LNode *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   free(L);</span>
<span> }</span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   </span><em><span>//**初始化</span></em><span> </span>
<span>   InitList(&amp;L);</span>
<span>   </span><em><span>//**尾插法</span></em><span> </span>
<span>   int m,n;</span>
<span>   printf(&quot;请输入链表元素个数:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;m);</span>
<span>   printf(&quot;请输入链表元素绝对值上限:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;n);</span>
<span>   TailList(L,m);</span>
<span>   </span><em><span>//**链表输出</span></em>
<span>   printf(&quot;原始链表：\n&quot;); </span>
<span>   PrintList(L);</span>
<span>   </span><em><span>//**删除重复项</span></em>
<span>   Remove(L,n) ;</span>
<span>   </span><em><span>//**输出</span></em><span> </span>
<span>   printf(&quot;删除重复项后的链表:\n&quot;);</span>
<span>   PrintList(L); </span>
<span>   </span><em><span>//**释放内存</span></em><span> </span>
<span>   FreeList(L);</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image028.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><em><strong><span>3</span><span>*</span></strong><span>**</span></em><span>）根据设计思想和实现步骤，采用</span><span>*</span><strong><span>*</span></strong><span>C</span><span>*</span><strong><span>*</span></strong><span>或者</span><span>*</span><strong><span>*</span></strong><span>C++</span><span>*</span><strong><span>*</span></strong><span>语言描述算法，关键之处请给出简要注释。</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span><span>#</span><span>include&lt;math.h&gt;</span>
<span> </span>
<span> typedef int ElemType;</span>
<span> typedef struct LNode{</span>
<span>   ElemType data;</span>
<span>   struct LNode </span><em><span>next;</span>
<span> }LNode,</span></em><span>LinkList;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitList(LinkList *L){</span>
<span>   </span><em><span>L=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>   if(</span><em><span>L==NULL){</span>
<span>    printf(&quot;Error.\n&quot;);</span>
<span>    return false;</span>
<span>   }</span>
<span>   (</span></em><span>L)-&gt;data=0;</span>
<span>   (*L)-&gt;next=NULL;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**尾插法</span></em>
<span> LinkList TailList(LinkList L,int m){</span>
<span>   if(m&lt;=0){</span>
<span>    return L;</span>
<span>   }</span>
<span>   LNode *tail=L;</span>
<span>   LNode </span><em><span>new;</span>
<span>   int x;</span>
<span>   printf(&quot;请输入链表元素(元素个数为%d):\n&quot;,m);</span>
<span>   for(int i=0;i&lt;m;i++){</span>
<span>    scanf(&quot;%d&quot;,&amp;x);</span>
<span>    new=(LNode</span></em><span>)malloc(sizeof(LNode));</span>
<span>    new-&gt;data=x;</span>
<span>    tail-&gt;next=new;</span>
<span>    tail=new;</span>
<span>   }</span>
<span>   tail-&gt;next=NULL;</span>
<span>   return L;</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//**删除重复项</span></em><span> </span>
<span> void Remove(LinkList L,int n){</span>
<span>   if(L==NULL || L-&gt;next==NULL){</span>
<span>    return;</span>
<span>   }</span>
<span>   </span><em><span>//**追踪每个绝对值是否出现过,|data|&lt;=n</span></em><span> </span>
<span>   bool </span><em><span>Lyst=(bool</span></em><span>)malloc((n+1)*sizeof(bool));</span>
<span>   for(int i=0;i&lt;=n;i++){</span>
<span>    Lyst[i]=false;</span>
<span>   }</span>
<span>   </span><em><span>//current</span></em><span> </span><em><span>指针用于遍历链表</span></em><span> </span>
<span>   LNode *current = L-&gt;next;</span>
<span>   </span><em><span>//prev</span></em><span> </span><em><span>用于存储current**的前一个节点</span></em><span> </span>
<span>   LNode *prev = L;</span>
<span> </span>
<span>   while(current != NULL){</span>
<span>    </span><em><span>//nextNode=current-&gt;next;</span></em>
<span>    int Value = abs(current-&gt;data);</span>
<span>    </span><em><span>//**检查当前节点的值是否已经出现</span></em>
<span>    if(!Lyst[Value]){ </span>
<span>      </span><em><span>//**标记为</span></em><span> </span><em><span>已出现</span></em><span> </span>
<span>      Lyst[Value]=true;</span>
<span>      prev = current;</span>
<span>      current = current-&gt;next;</span>
<span>    }else{</span>
<span>        prev-&gt;next = current-&gt;next;</span>
<span>        free(current);</span>
<span>        current = prev-&gt;next;</span>
<span>      }</span>
<span>    }</span>
<span>   }</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//**打印链表</span></em>
<span> void PrintList(LinkList L){</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   while(p != NULL){</span>
<span>    printf(&quot;%d-&gt;&quot;,p-&gt;data);</span>
<span>    p = p-&gt;next;</span>
<span>   }</span>
<span>   printf(&quot;NULL\n&quot;);</span>
<span> } </span>
<span> </span><em><span>//</span></em><span> </span><em><span>释放链表内存</span></em>
<span> void FreeList(LinkList L) {</span>
<span>   LNode *p = L-&gt;next;</span>
<span>   LNode *q;</span>
<span>   while (p != NULL) {</span>
<span>     q = p-&gt;next;</span>
<span>     free(p);</span>
<span>     p = q;</span>
<span>   }</span>
<span>   free(L);</span>
<span> }</span>
<span> int main(){</span>
<span>   LinkList L;</span>
<span>   </span><em><span>//**初始化</span></em><span> </span>
<span>   InitList(&amp;L);</span>
<span>   </span><em><span>//**尾插法</span></em><span> </span>
<span>   int m,n;</span>
<span>   printf(&quot;请输入链表元素个数:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;m);</span>
<span>   printf(&quot;请输入链表元素绝对值上限:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;,&amp;n);</span>
<span>   TailList(L,m);</span>
<span>   </span><em><span>//**链表输出</span></em>
<span>   printf(&quot;原始链表：\n&quot;); </span>
<span>   PrintList(L);</span>
<span>   </span><em><span>//**删除重复项</span></em>
<span>   Remove(L,n) ;</span>
<span>   </span><em><span>//**输出</span></em><span> </span>
<span>   printf(&quot;删除重复项后的链表:\n&quot;);</span>
<span>   PrintList(L); </span>
<span>   </span><em><span>//**释放内存</span></em><span> </span>
<span>   FreeList(L);</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image030.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><h5 id='4）说明你所设计算法的时间复杂度和空间复杂度'><em><strong><span>4</span><span>*</span></strong><span>**</span></em><span>）说明你所设计算法的时间复杂度和空间复杂度。</span><span>*</span><span>**</span></h5><p><span>#</span><span>时间复杂度：</span>
<span> 1、初始化数组Lyst需要遍历索引，需要 O(n)。</span>
<span> 2、遍历链表：使用while循环遍历链表,时间复杂度也是 O(n)。</span>
<span> 3、检查true的时间复杂度为 O(1)。</span>
<span> 总之，时间复杂度为 O(n) 。</span>
<span> </span><span>#</span><span>空间复杂度：</span>
<span> 1、布尔数组：需要空间 O(n)的空间</span>
<span> 2、几个指针变量的空间为 O(1)。</span>
<span> 总之，空间复杂度为 O(n) 。</span></p><p><span>*</span><strong><span>第四次作业：</span><span>*</span></strong></p><p><em><strong><span>（</span><span>*</span></strong><span>**</span></em><span>1</span><span>*</span><strong><span>*</span></strong><span>）括号匹配</span><span>*</span><span>**</span></p><p><span>遇到左括号就入栈</span>
<span> 遇到有括号，就抵消一个左括号</span>
<span> 不匹配的情况</span>
<span> 遇到一个右括号，栈内弹出的左括号与之不匹配，例如 此时的右括号是 ] 而栈内的左括号是 {</span>
<span> 匹配到最后一个括号。栈内已经空了，说明此时多出来了括号</span>
<span> 处理完所有括号，栈内非空</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image032.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdbool.h&gt;</span>
<span> </span><span>#</span><span>include&lt;string.h&gt; </span>
<span> </span>
<span> </span><span>#</span><span>define INIT_SIZE 10 </span>
<span> </span><span>#</span><span>define INCREASE 10</span>
<span> </span><span>#</span><span>define MaxSize 100 </span><em><span>//**定义最大长度</span></em><span> </span>
<span> </span>
<span> typedef char ElemType;</span>
<span> typedef struct{</span>
<span>   ElemType *base; </span><em><span>//**栈底</span></em>
<span>   ElemType *top; </span><em><span>//**栈顶</span></em>
<span>   int stacksize; </span><em><span>//**已分配存储空间</span></em><span> </span>
<span> }SqStack;</span>
<span> </span><em><span>//**初始化</span></em>
<span> bool InitStack(SqStack </span><em><span>S){</span>
<span>   S-&gt;base=(ElemType</span></em><span>)malloc(INIT_SIZE</span>
<span>    *sizeof(ElemType));</span>
<span>   if(!S-&gt;base) </span><em><span>//**分配失败</span></em><span> </span>
<span>    return false;</span>
<span>   S-&gt;top = S-&gt;base;</span>
<span>   S-&gt;stacksize = INIT_SIZE;</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**进栈</span></em>
<span> bool Push(SqStack *S,ElemType e){</span>
<span>   if(S-&gt;top-S-&gt;base&gt;=S-&gt;stacksize){</span>
<span>    </span><em><span>//**栈满</span></em>
<span>    ElemType </span><em><span>newBase=(ElemType</span></em><span>)realloc(S-&gt;base,</span>
<span>      (S-&gt;stacksize+INCREASE)*sizeof(ElemType));</span>
<span>     if (!newBase)</span>
<span>       return false;</span>
<span>     S-&gt;base = newBase;</span>
<span>     S-&gt;top = S-&gt;base + S-&gt;stacksize;</span>
<span>     S-&gt;stacksize += INCREASE;</span>
<span>   }</span>
<span>   *S-&gt;top++ = e; </span><em><span>/**</span></em><span>首先，</span><span>*</span><span>S.top</span><strong><span>解引用top</span></strong><span>指针，获取*</span>
<span>   </span><em><span>当前指向的位置。</span><strong><span>然后，将元素</span></strong><span>e**的值赋给这个位置。</span></em>
<span>   </span><em><span>接着，</span><strong><span>S.top++</span></strong><span>将</span><strong><span>top</span></strong><span>指针向前移动一个位置，指向下一</span></em>
<span>   </span><em><span>个空闲的位置。**</span></em><span>/*</span>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**出栈</span></em>
<span> bool Pop(SqStack *S,ElemType *e){</span>
<span>   if(S-&gt;top == S-&gt;base)</span>
<span>    return false;</span>
<span>   *e = *--S-&gt;top; </span><em><span>/**</span></em><span>首先，</span><strong><span>--S.top</span></strong><span>将</span><strong><span>top</span></strong><span>指针向前移动一个*</span>
<span>   </span><em><span>位置，指向栈顶元素。然后，</span><strong><span>*</span></strong><span>操作符用于解引用指针，</span></em>
<span>   </span><em><span>获取指向的元素值，并将其赋值给引用参数</span><strong><span>e</span></strong><span>。</span></em>
<span>   </span><em><span>这样，e**就存储了从栈中弹出的元素。</span><span>*</span><span>/</span></em>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**取栈顶元素</span></em>
<span> bool GetTop(SqStack *S,ElemType *e){</span>
<span>   if(S-&gt;top == S-&gt;base)</span>
<span>    return false;</span>
<span>   *e = *(S-&gt;top - 1); </span><em><span>/</span><span>*</span><span>S.top-1</span><strong><span>将top</span></strong><span>指针向前移动一个</span></em>
<span>   </span><em><span>位置，指向栈顶元素。然后，**</span></em><span>操作符用于解引用*</span>
<span>   </span><em><span>指针，获取指向的元素值，并将其赋值给引用参数e</span><span>*</span><span>/</span></em>
<span>   return true;</span>
<span> } </span>
<span> </span><em><span>//**判断为空</span></em>
<span> bool StackEmpty(SqStack *S){</span>
<span>   return S-&gt;top == S-&gt;base;</span>
<span> } </span>
<span> </span><em><span>//</span></em><span> </span><em><span>括号匹配</span></em>
<span> bool BracketCheck(SqStack *S, char str[], int length) {</span>
<span>   for (int i = 0; i &lt; length; i++) {</span>
<span>     if (str[i] == &#39;(&#39; || str[i] == &#39;[&#39; || str[i] == &#39;{&#39;) {</span>
<span>       Push(S, str[i]);</span>
<span>     } else {</span>
<span>       if (StackEmpty(S))</span>
<span>         return false;</span>
<span>       ElemType topElem;</span>
<span>       if (!Pop(S, &amp;topElem))</span>
<span>         return false;</span>
<span>       if ((str[i] == &#39;)&#39; &amp;&amp; topElem != &#39;(&#39;) ||</span>
<span>         (str[i] == &#39;]&#39; &amp;&amp; topElem != &#39;[&#39;) ||</span>
<span>         (str[i] == &#39;}&#39; &amp;&amp; topElem != &#39;{&#39;))</span>
<span>         return false;</span>
<span>     }</span>
<span>   }</span>
<span>   return StackEmpty(S);</span>
<span> }</span>
<span> </span>
<span> int main() {</span>
<span>   SqStack S;</span>
<span>   if (!InitStack(&amp;S)) {</span>
<span>     printf(&quot;栈初始化失败！\n&quot;);</span>
<span>     return 1;</span>
<span>   }</span>
<span>   char s[MaxSize];</span>
<span>   printf(&quot;请输入需要判断的括号：\n&quot;);</span>
<span>   scanf(&quot;%99s&quot;, s); </span><em><span>//</span></em><span> </span><em><span>限制输入长度，防止溢出</span></em>
<span>   int len = strlen(s);</span>
<span>   printf(&quot;当前输入的括号个数为：%d\n&quot;, len);</span>
<span>   printf(&quot;--------现在开始进行判断--------\n&quot;);</span>
<span>   if (BracketCheck(&amp;S, s, len)) {</span>
<span>     printf(&quot;匹配成功！\n&quot;);</span>
<span>   } else {</span>
<span>     printf(&quot;匹配失败！\n&quot;);</span>
<span>   }</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>释放栈内存</span></em>
<span>   free(S.base);</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image034.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p><em><strong><span>（</span><span>*</span></strong><span>**</span></em><span>2</span><span>*</span><strong><span>*</span></strong><span>）算术表达式计算（两种方法都要实现：方法一先输出后缀表达式然后计算结果；方法二直接出结果</span><span>*</span><span>**</span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span><span>#</span><span>include&lt;ctype.h&gt;</span>
<span> </span><span>#</span><span>include&lt;string.h&gt;</span>
<span> </span>
<span> </span><span>#</span><span>define MAXSIZE 100</span>
<span> </span>
<span> </span><em><span>//**栈结构定义</span></em>
<span> typedef struct{</span>
<span>   char data[MAXSIZE];</span>
<span>   int top;</span>
<span> }Stack;</span>
<span> </span>
<span> </span><em><span>//**初始化栈</span></em>
<span> void initStack(Stack *S){</span>
<span>   S-&gt;top = -1;</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//**判空</span></em>
<span> int isEmpty(Stack *S){</span>
<span>   return S-&gt;top == -1;</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//**判断是否已满</span></em>
<span> int isFull(Stack *S){</span>
<span>   return S-&gt;top == MAXSIZE - 1;</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//**入栈</span></em>
<span> void Push(Stack *S,char elem){</span>
<span>   if(!isFull(S)){</span>
<span>    S-&gt;data[++(S-&gt;top)] = elem;</span>
<span>   }</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//**出栈</span></em>
<span> int Pop(Stack *S){</span>
<span>   if(!isEmpty(S)){</span>
<span>    return S-&gt;data[(S-&gt;top)--];</span>
<span>   }</span>
<span>   return -1;</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//**获取栈顶</span></em>
<span> int Peek(Stack *S){</span>
<span>   if(!isEmpty(S)){</span>
<span>    return S-&gt;data[S-&gt;top];</span>
<span>   }</span>
<span>   return -1;</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//**操作符优先级</span></em>
<span> int Priority(char op){</span>
<span>   switch(op){</span>
<span>    case &#39;+&#39;: case &#39;-&#39;: return 1;</span><em><span>//**优先级是1</span></em>
<span>    case &#39;</span><em><span>&#39;: case &#39;/&#39;: return 2;</span></em><span>//</span><strong><span>优先级是2*</span>
<span>    default: return 0;</span>
<span>   }</span>
<span> } </span>
<span> </span>
<span> *//</span></strong><span>中缀转后缀*</span>
<span> void transform(char *infix,char *postfix){</span>
<span>   </span><em><span>// infix</span><strong><span>存储中缀表达式 , postfix</span></strong><span>存储后缀表达式</span></em><span> </span>
<span>   int i,k=0; </span>
<span>   Stack S; </span><em><span>//**临时存储操作符和括号</span></em><span> </span>
<span>   initStack(&amp;S);</span>
<span>   for(i=0; infix[i]!=&#39;\0&#39;; i++){</span>
<span>    if(isdigit(infix[i])){</span>
<span>      char num[11]; </span><em><span>//**存储数字</span></em>
<span>      int j = 0;</span>
<span>      while(isdigit(infix[i])){</span>
<span>        num[j++] = infix[i++];</span>
<span>      } </span>
<span>      num[j] = &#39;\0&#39;;</span>
<span>      strcpy(postfix+k,num);</span>
<span>      k += j;</span>
<span>      postfix[k++] = &#39; &#39;; </span><em><span>//**用空格分隔数字</span></em>
<span>      i--; </span><em><span>//</span><strong><span>因为for</span></strong><span>循环会再次增加</span></em><span> </span>
<span>    }else if(infix[i]==&#39;(&#39;){</span>
<span>      Push(&amp;S,infix[i]);</span>
<span>      </span><em><span>//**遇到左括号，压入栈</span></em><span> </span>
<span>    }else if(infix[i]==&#39;)&#39;){</span>
<span>      </span><em><span>//**遇到右括号,</span></em><span> </span>
<span>      while(!isEmpty(&amp;S) &amp;&amp; Peek(&amp;S)!=&#39;(&#39;){</span>
<span>        postfix[k++] = Pop(&amp;S);</span>
<span>        postfix[k++] = &#39; &#39;; </span><em><span>//**空格隔开</span></em><span> </span>
<span>      }</span>
<span>      if(!isEmpty(&amp;S)){</span>
<span>        Pop(&amp;S); </span><em><span>//**删除&#39;(&#39;</span></em><span> </span>
<span>      } </span>
<span>    }</span>
<span>    else{</span>
<span>      </span><em><span>/**</span></em><span>如果当前字符是一个操作符，则比较*</span>
<span>      </span><em><span>其优先级与栈顶元素的优先级</span><span>*</span><span>/</span></em><span> </span>
<span>      while( !isEmpty(&amp;S) &amp;&amp; </span>
<span>       Priority(Peek(&amp;S)) &gt;= Priority(infix[i]) ){</span>
<span>      postfix[k++] = Pop(&amp;S); </span>
<span>      postfix[k++] = &#39; &#39;;</span>
<span>      </span><em><span>/**</span></em><span>栈顶元素的优先级小于或等于当前操作符的优先级，*</span>
<span>      </span><em><span>则弹出栈顶元素并添加到后缀表达式中，</span></em>
<span>      </span><em><span>直到遇到优先级更低的操作符或栈为空。</span><span>*</span><span>/</span></em>
<span>      }</span>
<span>      Push(&amp;S,infix[i]);</span>
<span>    }</span>
<span>   }</span>
<span>   while(!isEmpty(&amp;S)){</span>
<span>    postfix[k++] = Pop(&amp;S);</span>
<span>    postfix[k++] = &#39; &#39;;</span>
<span>   </span><em><span>/**</span></em><span>将它们全部弹出并添加到后缀表达式中。*</span>
<span>   </span><em><span>这些通常是没有被括号包围的操作符</span><span>*</span><span>/</span></em><span> </span>
<span>   }</span>
<span>   postfix[k] = &#39;\0&#39;;</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//**计算后缀表达式的值</span></em>
<span> int evaluate(char *postfix){</span>
<span>   Stack S;</span>
<span>   initStack(&amp;S);</span>
<span>   </span><em><span>//</span><strong><span>用 strtok</span></strong><span>函数，根据&quot; &quot;**分隔成多个字符串</span></em><span> </span>
<span>   char </span><em><span>token = strtok(postfix,&quot; &quot;);</span>
<span>   while(token){</span>
<span>    if(isdigit(</span></em><span>token)){</span>
<span>      Push(&amp;S,atoi(token));</span>
<span>      </span><em><span>// atoi**函数将字符串转换为一个整数</span></em><span> </span>
<span>    }</span>
<span>    else{</span>
<span>      int num1 = Pop(&amp;S);</span>
<span>      int num2 = Pop(&amp;S);</span>
<span>      int result;</span>
<span>      switch(</span><em><span>token){</span>
<span>        case &#39;+&#39;: result = num2 + num1; break;</span>
<span>        case &#39;-&#39;: result = num2 - num1; break;</span>
<span>        case &#39;</span></em><span>&#39;: result = num2 * num1; break;</span>
<span>        case &#39;/&#39;: if(num1==0){</span>
<span>          printf(&quot;除数不为0\n&quot;);</span>
<span>          exit(1);</span>
<span>        }</span>
<span>        result = num2 / num1;</span>
<span>        break;</span>
<span>      }</span>
<span>      Push(&amp;S,result);</span>
<span>    }</span>
<span>    token = strtok(NULL,&quot; &quot;);</span>
<span>   }</span>
<span>   return Pop(&amp;S);</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   char infix[MAXSIZE], postfix[MAXSIZE];</span>
<span>   printf(&quot;输入中缀表达式：\n&quot;);</span>
<span>   scanf(&quot;%s&quot;,infix);</span>
<span>   transform(infix,postfix);</span>
<span>   printf(&quot;后缀表达式为：%s\n&quot;,postfix);</span>
<span>   printf(&quot;Result:%d\n&quot;,evaluate(postfix));</span>
<span>   return 0;</span>
<span> }</span></p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image036.png" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h4 id='第五次作业'><span>第五次作业</span></h4><p><span>*</span><span> 题目描述</span></p><p><span>给定一个二维的 0-1 矩阵，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。</span></p><p><span>*</span><span> 输入输出样例</span></p><p><span>输入是一个二维数组，输出是一个整数，表示最大的岛屿面积。</span></p><p><span>Input:</span></p><p><span>[ [1,0,1,1,0,1,0,1],</span></p><p><span> [1,0,1,1,0,1,1,1],</span></p><p><span> [0,0,0,0,0,0,0,1] ]</span></p><p><span>Output: 6</span></p><p><span>最大的岛屿面积为 6，位于最右侧。</span></p><p><span> </span></p><p>&nbsp;</p><h4 id='方法一深度优先搜索'><span>方法一：深度优先搜索</span></h4><p><span>dfs 方法（深度优先搜索）用于计算以当前位置 (cur_i, cur_j) 为起点的岛屿的面积。这个方法首先检查当前位置是否越界或者是否为陆地（即单元格的值是否为1）。如果不满足条件，则返回0。然后，将当前位置标记为已访问（将 grid</span>[<span>cur_i</span>][cur_j]<span> 设置为0），并计算从当前位置出发，向四个方向（上、下、左、右）扩展的岛屿面积。每次递归调用 dfs 方法时，都会累加面积 ans。</span>
<span> </span>
<span> maxIsland 用于计算整个岛屿的最大面积。它遍历整个矩阵的每个单元格，对于每个值为1的单元格，调用 dfs 方法计算以该单元格为起点的岛屿面积，并通过 max 函数更新最大面积 ans。最后返回计算出的最大岛屿面积。</span></p><p><span>#</span><span>include &lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include &lt;string.h&gt;</span>
<span> </span>
<span> </span><span>#</span><span>define MAX_SIZE 100 </span><em><span>//</span></em><span> </span><em><span>假设最大为**100</span><span>*</span><span>100</span></em>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>定义一个存储二维数组的尺寸信息</span></em>
<span> typedef struct {</span>
<span>   int rows;</span>
<span>   int cols;</span>
<span>   int grid</span>[<span>MAX_SIZE</span>][MAX_SIZE]<span>;</span>
<span> } Island;</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>深度优先搜索，计算岛屿面积</span></em>
<span> int dfs(Island *island, int rows, int cols, int cur_i, int cur_j) {</span>
<span>   if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i &gt;= rows || cur_j &gt;= cols || island-&gt;grid</span>[<span>cur_i</span>][cur_j]<span> != 1) {</span>
<span>     return 0;</span>
<span>   }</span>
<span>   island-&gt;grid</span>[<span>cur_i</span>][cur_j]<span> = 0; </span><em><span>//</span><strong><span>已检阅数组标记为</span></strong><span>0</span></em><span> </span>
<span>   int ans = 1; </span><em><span>//</span></em><span> </span><em><span>岛屿面积</span></em>
<span>   int di[] = {0, 0, 1, -1}; </span><em><span>//</span></em><span> </span><em><span>行</span><strong><span>i</span></strong><span>的相对运动</span></em>
<span>   int dj[] = {1, -1, 0, 0}; </span><em><span>//</span></em><span> </span><em><span>列</span><strong><span>j</span></strong><span>的相对运动</span></em>
<span>   for (int index = 0; index &lt; 4; ++index) {</span>
<span>     int next_i = cur_i + di[index];</span>
<span>     int next_j = cur_j + dj[index];</span>
<span>     </span><em><span>/</span><span>*</span><span>di[0] = 0</span></em><span> </span><em><span>和</span></em><span> </span><em><span>dj[0] = 1**：表示向右移动</span></em>
<span>    </span><em><span>di[1] = 0</span></em><span> </span><em><span>和</span></em><span> </span><em><span>dj[1] = -1**：表示向左移动</span></em>
<span>    </span><em><span>di[2] = 1</span></em><span> </span><em><span>和</span></em><span> </span><em><span>dj[2] = 0**：表示向下移动</span></em>
<span>    </span><em><span>di[3] = -1</span></em><span> </span><em><span>和</span></em><span> </span><em><span>dj[3] = 0</span><strong><span>：表示向上移动</span></strong></em><span>/*</span>
<span>     ans += dfs(island, rows, cols, next_i, next_j);</span>
<span>   }</span>
<span>   return ans;</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>自定义</span></em><span> </span><em><span>max</span></em><span> </span><em><span>函数</span></em>
<span> int fun_max(int a, int b) {</span>
<span>   return (a &gt; b) ? a : b;</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>计算最大岛屿面积</span></em>
<span> int maxIsland(Island island) {</span>
<span>   int ans = 0;</span>
<span>   for (int i = 0; i &lt; island.rows; ++i) {</span>
<span>     for (int j = 0; j &lt; island.cols; ++j) {</span>
<span>       if (island.grid</span>[<span>i</span>][j]<span> == 1) {</span>
<span>         ans = fun_max(ans, dfs(&amp;island, island.rows, island.cols, i, j));</span>
<span>         island.grid</span>[<span>i</span>][j]<span> = 1; </span><em><span>//</span></em><span> </span><em><span>重置为**1</span></em>
<span>       }</span>
<span>     }</span>
<span>   }</span>
<span>   return ans;</span>
<span> }</span>
<span> </span>
<span> int main() {</span>
<span>   int row, col;</span>
<span>   printf(&quot;最大行数:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;, &amp;row);</span>
<span>   printf(&quot;最大列数:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;, &amp;col);</span>
<span>   Island island;</span>
<span>   island.rows = row;</span>
<span>   island.cols = col;</span>
<span>   for (int i = 0; i &lt; row; i++) {</span>
<span>     for (int j = 0; j &lt; col; j++) {</span>
<span>       scanf(&quot;%d&quot;, &amp;island.grid</span>[<span>i</span>][j]<span>);</span>
<span>     }</span>
<span>     putchar(&#39;\n&#39;);</span>
<span>   }</span>
<span>   int maxArea = maxIsland(island);</span>
<span>   printf(&quot;最大面积是:%d\n&quot;, maxArea);</span>
<span>   return 0;</span>
<span> }</span></p><p><span> </span></p><p>&nbsp;</p><h4 id='方法二广度优先'><span>方法二：广度优先</span></h4><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;limits.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>比较两个整数，返回较大的那个</span></em>
<span> int max(int a, int b) {</span>
<span>   return (a &gt; b) ? a : b;</span>
<span> }</span>
<span> </span>
<span> int maxAreaOfIsland(int</span><em><span>* grid, int gridSize, int</span></em><span> gridColSize) {</span>
<span>   int m = gridColSize[0], n = gridSize, ans = 0; </span><em><span>//m</span><strong><span>表示列数，n</span></strong><span>表示行数</span></em><span> </span>
<span>   int d</span>[<span>4</span>][2]<span> = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};</span>
<span>   </span><em><span>/</span><span>*</span><span>{0, -1}</span></em><span> </span><em><span>表示向上移动。</span></em>
<span>    </span><em><span>{0, 1}</span></em><span> </span><em><span>表示向下移动</span></em>
<span>    </span><em><span>{-1, 0}</span></em><span> </span><em><span>表示向左移动</span></em>
<span>    </span><em><span>{1, 0}</span></em><span> </span><em><span>表示向右移动</span><span>*</span><span>/</span></em>
<span>   for (int i = 0; i &lt; n; ++i) {</span>
<span>     for (int j = 0; j &lt; m; ++j) {</span>
<span>       if (grid</span>[<span>i</span>][j]<span>) {</span>
<span>         grid</span>[<span>i</span>][j]<span> = 0; </span><em><span>//**标记为已访问</span></em><span> </span>
<span>         </span><em><span>//</span><strong><span>变量p</span></strong><span>用于计数连通区域的大小</span></em>
<span>         </span><em><span>//</span><strong><span>初始化队列que</span></strong><span>用于BFS</span><strong><span>，l</span></strong><span>和r**分别表示队列的头和尾。</span></em>
<span>         int p = 1, que</span>[<span>20000</span>][2]<span>, l = 0, r = 0;</span>
<span>         </span><em><span>//</span><strong><span>将当前位置(i, j)</span></strong><span>入队。</span></em>
<span>         que</span>[<span>r</span>][0]<span> = i, que</span>[<span>r++</span>][1]<span> = j;</span>
<span>         while (l &lt; r) { </span><em><span>//**当队列不为空时</span></em>
<span>          </span><em><span>//**出队一个元素，得到当前要处理的位置(x, y)</span></em>
<span>           int x = que</span>[<span>l</span>][0]<span>, y = que</span>[<span>l++</span>][1]<span>;</span>
<span>           for (int k = 0; k &lt; 4; k++) { </span><em><span>//**遍历四个方向（上、下、左、右）</span></em>
<span>            </span><em><span>//</span><strong><span>计算新位置(mx, my)</span></strong><span>，d**是一个二维数组，存储了四个方向的偏移量</span></em>
<span>             int mx = x + d</span>[<span>k</span>][0]<span>, my = y + d</span>[<span>k</span>][1]<span>;</span>
<span>             </span><em><span>//**检查新位置是否在网格内且为连通区域的一部分</span></em>
<span>             if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; grid</span>[<span>mx</span>][my]<span>) {</span>
<span>               </span><em><span>//**如果新位置有效，将其入队</span></em>
<span>               que</span>[<span>r</span>][0]<span> = mx, que</span>[<span>r++</span>][1]<span> = my;</span>
<span>               grid</span>[<span>mx</span>][my]<span> = 0; p++;</span>
<span>             }</span>
<span>           }</span>
<span>         }</span>
<span>         ans = max(ans, p);</span>
<span>       }</span>
<span>     }</span>
<span>   }</span>
<span>   return ans;</span>
<span> }</span>
<span> </span>
<span> int main() {</span>
<span>   int row, col;</span>
<span>   printf(&quot;输入行数:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;, &amp;row);</span>
<span>   printf(&quot;输入列数:\n&quot;);</span>
<span>   scanf(&quot;%d&quot;, &amp;col);</span>
<span>   int** grid = (int**)malloc(row * sizeof(int</span><em><span>));</span>
<span>   for (int i = 0; i &lt; row; i++) {</span>
<span>     grid[i] = (int</span></em><span>)malloc(col * sizeof(int));</span>
<span>   }</span>
<span>   for (int i = 0; i &lt; row; i++) {</span>
<span>     for (int j = 0; j &lt; col; j++) {</span>
<span>       scanf(&quot;%d&quot;, &amp;grid</span>[<span>i</span>][j]<span>);</span>
<span>     }</span>
<span>     putchar(&#39;\n&#39;);</span>
<span>   }</span>
<span>   int* gridColSize = (int*)malloc(1 * sizeof(int));</span>
<span>   gridColSize[0] = col;</span>
<span>   int maxArea = maxAreaOfIsland(grid, row, gridColSize);</span>
<span>   printf(&quot;最大面积是:%d\n&quot;, maxArea);</span>
<span>   for (int i = 0; i &lt; row; i++) {</span>
<span>     free(grid[i]);</span>
<span>   }</span>
<span>   free(grid);</span>
<span>   free(gridColSize);</span>
<span>   return 0;</span>
<span> }</span></p><p><span> </span></p><p>&nbsp;</p><h3 id='6第六次作业'><span>6、第六次作业</span></h3><h4 id='在先序遍历中建立以下二叉树再中序遍历和后序遍历并输出结果'><span>在先序遍历中建立以下二叉树，再中序遍历和后序遍历并输出结果。</span></h4><p><span> </span></p><p><span>#</span><span>include&lt;stdio.h&gt;</span>
<span> </span><span>#</span><span>include&lt;stdlib.h&gt;</span>
<span> </span>
<span> typedef struct TreeNode{</span>
<span>   char data;</span>
<span>   struct TreeNode *left;</span>
<span>   struct TreeNode *right;</span>
<span> } TreeNode;</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>创建一个新结点</span></em>
<span> TreeNode* createNode(char elem){</span>
<span>   TreeNode* newNode=(TreeNode*)malloc(sizeof(TreeNode));</span>
<span>   if(newNode==NULL){</span>
<span>     printf(&quot;Error.\n&quot;);</span>
<span>     exit(1);</span>
<span>   }</span>
<span>   newNode-&gt;data = elem;</span>
<span>   newNode-&gt;left = NULL;</span>
<span>   newNode-&gt;right = NULL;</span>
<span>   return newNode;</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>向二叉树插入结点</span></em>
<span> TreeNode* buildTree(char* preorder, int* index) {</span>
<span>   if (preorder[*index] == &#39;\0&#39;) {</span>
<span>     return NULL;</span>
<span>   }</span>
<span> </span><br/><span>   </span><em><span>//</span></em><span> </span><em><span>创建一个新的树节点，内容为 preorder</span></em><span> </span><em><span>中当前 index</span></em><span> </span><em><span>位置的字符</span></em>
<span>   TreeNode* root = createNode(preorder[</span><em><span>index]);</span>
<span>   (</span></em><span>index)++;</span>
<span> </span>
<span>   </span><em><span>//</span></em><span> </span><em><span>如果当前节点是运算符，则需要继续构建左右子树</span></em>
<span>   if (root-&gt;data == &#39;+&#39; || root-&gt;data == &#39;-&#39; || root-&gt;data == &#39;*&#39; || root-&gt;data == &#39;/&#39;) {</span>
<span>     root-&gt;left = buildTree(preorder, index);</span>
<span>     root-&gt;right = buildTree(preorder, index);</span>
<span>   }</span>
<span> </span>
<span>   return root;</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>访问节点的函数</span></em>
<span> void visit(TreeNode* node){</span>
<span>   if(node != NULL){</span>
<span>     printf(&quot;%c &quot;, node-&gt;data);</span>
<span>   }</span>
<span> }</span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>中序遍历</span></em>
<span> void inorder(TreeNode* root){</span>
<span>   if(root != NULL){</span>
<span>     inorder(root-&gt;left);</span>
<span>     visit(root);</span>
<span>     inorder(root-&gt;right);</span>
<span>   }</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>后序遍历</span></em>
<span> void postorder(TreeNode* root){</span>
<span>   if(root != NULL){</span>
<span>     postorder(root-&gt;left);</span>
<span>     postorder(root-&gt;right);</span>
<span>     visit(root);</span>
<span>   }</span>
<span> } </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>释放二叉树内存</span></em>
<span> void freeTree(TreeNode* root){</span>
<span>   if(root != NULL){</span>
<span>     freeTree(root-&gt;left);</span>
<span>     freeTree(root-&gt;right);</span>
<span>     free(root);</span>
<span>   }</span>
<span> } </span>
<span> </span>
<span> int main(){</span>
<span>   char preorder[] = &quot;-+a*b-cd/ef&quot;;</span>
<span>   int index = 0; </span><em><span>//</span></em><span> </span><em><span>指向当前处理位置</span></em><span> </span>
<span>   </span><em><span>//</span></em><span> </span><em><span>建立二叉树</span></em>
<span>   TreeNode* root = buildTree(preorder, &amp;index);</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>中序遍历</span></em>
<span>   printf(&quot;中序遍历结果:\n&quot;);</span>
<span>   inorder(root);</span>
<span>   printf(&quot;\n&quot;);</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>后序遍历</span></em>
<span>   printf(&quot;后序遍历结果:\n&quot;);</span>
<span>   postorder(root);</span>
<span>   printf(&quot;\n&quot;);</span>
<span>   </span><em><span>//</span></em><span> </span><em><span>释放内存</span></em>
<span>   freeTree(root);</span>
<span> </span><br/><span>   return 0;</span>
<span> }</span></p><p><span> </span></p><p><span> </span></p><p><span> </span></p><p><span> </span></p><h3 id='第八次作业'><span>第八次作业</span></h3><p><span>图的广度优先遍历和图的深度优先遍历</span></p><p><span>#</span><span>include &lt;stdio.h&gt; </span>
<span> </span><span>#</span><span>include &lt;stdlib.h&gt; </span>
<span> </span>
<span> </span><span>#</span><span>define MAX 20 </span>
<span> </span>
<span> typedef struct EdgeNode { </span>
<span>   int adjvex;     </span><br/><span>   struct EdgeNode *next; </span>
<span>   int weight;     </span><br/><span> } EdgeNode; </span>
<span> </span>
<span> </span>
<span> typedef struct VertexNode { </span>
<span>   char data;     </span><br/><span>   EdgeNode *firstedge;</span><br/><span> } VertexNode; </span>
<span> </span>
<span> </span>
<span> typedef struct { </span>
<span>   VertexNode adjlist[MAX]; </span>
<span>   int n, e;       </span><em><span>//</span></em><span> </span><em><span>顶点数和边数</span></em><span> </span>
<span> } GraphAdjlist; </span>
<span> </span>
<span> int visited[MAX]; </span><em><span>//</span></em><span> </span><em><span>访问标志数组（访问过赋值为1</span><strong><span>，未访问赋值为0</span></strong><span>）</span></em><span> </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>创建邻接表</span></em><span> </span>
<span> void create(GraphAdjlist *G) { </span>
<span>   int i, j, k; </span>
<span>   EdgeNode *e; </span>
<span> </span>
<span>   printf(&quot;请输入顶点数和边数：&quot;); </span>
<span>   scanf(&quot;%d%d&quot;, &amp;G-&gt;n, &amp;G-&gt;e); </span>
<span>   getchar(); </span><em><span>//</span></em><span> </span><em><span>清除缓冲</span></em><span> </span>
<span> </span>
<span>   printf(&quot;请输入顶点标号：\n&quot;); </span>
<span>   for (i = 0; i &lt; G-&gt;n; i++) { </span>
<span>     scanf(&quot;%c&quot;, &amp;G-&gt;adjlist[i].data); </span><em><span>//</span></em><span> </span><em><span>输入顶点编号</span></em><span> </span>
<span>     G-&gt;adjlist[i].firstedge = NULL;  </span><em><span>//</span></em><span> </span><em><span>初始化边表为空</span></em><span> </span>
<span>     getchar(); </span>
<span>   } </span>
<span> </span>
<span>   for (k = 0; k &lt; G-&gt;e; k++) { </span>
<span>     printf(&quot;输入边 (Vi, Vj) 上的顶点序号：\n&quot;); </span>
<span>     scanf(&quot;%d%d&quot;, &amp;i, &amp;j); </span>
<span> </span>
<span>     </span><em><span>//</span></em><span> </span><em><span>使用头插法加入边表结点</span></em><span> </span>
<span>     e = (EdgeNode *)malloc(sizeof(EdgeNode)); </span>
<span>     e-&gt;adjvex = j; </span>
<span>     e-&gt;next = G-&gt;adjlist[i].firstedge; </span>
<span>     G-&gt;adjlist[i].firstedge = e; </span>
<span> </span>
<span>     </span><em><span>//</span></em><span> </span><em><span>无向图：对称加入边表结点</span></em><span> </span>
<span>     e = (EdgeNode *)malloc(sizeof(EdgeNode)); </span>
<span>     e-&gt;adjvex = i; </span>
<span>     e-&gt;next = G-&gt;adjlist[j].firstedge; </span>
<span>     G-&gt;adjlist[j].firstedge = e; </span>
<span>   } </span>
<span>   printf(&quot;\n&quot;); </span>
<span> } </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>深度优先搜索</span></em><span> </span>
<span> void DFS(GraphAdjlist *G, int i) { </span>
<span>   EdgeNode *p; </span>
<span>   visited[i] = 1; </span>
<span>   printf(&quot;%c &quot;, G-&gt;adjlist[i].data); </span>
<span> </span>
<span>   p = G-&gt;adjlist[i].firstedge; </span>
<span>   while (p != NULL) { </span>
<span>     if (visited[p-&gt;adjvex] == 0) { </span>
<span>       DFS(G, p-&gt;adjvex); </span>
<span>     } </span>
<span>     p = p-&gt;next; </span>
<span>   } </span>
<span> } </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>深度优先遍历</span></em><span> </span>
<span> void DFSTraverse(GraphAdjlist *G) { </span>
<span>   for (int i = 0; i &lt; G-&gt;n; i++) { </span>
<span>     visited[i] = 0; </span><em><span>//</span></em><span> </span><em><span>初始化访问标志</span></em><span> </span>
<span>   } </span>
<span>   for (int i = 0; i &lt; G-&gt;n; i++) { </span>
<span>     if (visited[i] == 0) { </span>
<span>       DFS(G, i); </span>
<span>     } </span>
<span>   } </span>
<span> } </span>
<span> </span>
<span> </span><em><span>//</span></em><span> </span><em><span>广度优先搜索</span></em><span> </span>
<span> void BFS(GraphAdjlist *G, int v) { </span>
<span>   EdgeNode *p; </span>
<span>   int queue[MAX], front = 0, rear = 0; </span>
<span>   int w; </span>
<span> </span>
<span>   for (int i = 0; i &lt; G-&gt;n; i++) { </span>
<span>     visited[i] = 0; </span><em><span>//</span></em><span> </span><em><span>初始化访问标志</span></em><span> </span>
<span>   } </span>
<span> </span>
<span>   printf(&quot;%c &quot;, G-&gt;adjlist[v].data); </span>
<span>   visited[v] = 1; </span>
<span>   rear = (rear + 1) % MAX; </span>
<span>   queue[rear] = v; </span>
<span> </span>
<span>   while (front != rear) { </span>
<span>     front = (front + 1) % MAX; </span>
<span>     w = queue[front]; </span>
<span> </span>
<span>     p = G-&gt;adjlist[w].firstedge; </span>
<span>     while (p != NULL) { </span>
<span>       if (visited[p-&gt;adjvex] == 0) { </span>
<span>         printf(&quot;%c &quot;, G-&gt;adjlist[p-&gt;adjvex].data); </span>
<span>         visited[p-&gt;adjvex] = 1; </span>
<span>         rear = (rear + 1) % MAX; </span>
<span>         queue[rear] = p-&gt;adjvex; </span>
<span>       } </span>
<span>       p = p-&gt;next; </span>
<span>     } </span>
<span>   } </span>
<span>   printf(&quot;\n&quot;); </span>
<span> } </span>
<span> </span>
<span> int main() { </span>
<span>   GraphAdjlist G; </span>
<span>   create(&amp;G); </span>
<span> </span>
<span>   printf(&quot;深度优先遍历：&quot;); </span>
<span>   DFSTraverse(&amp;G); </span>
<span> </span>
<span>   printf(&quot;\n广度优先遍历：&quot;); </span>
<span>   BFS(&amp;G, 0); </span>
<span> </span>
<span>   return 0; </span>
<span> } </span></p><p>&nbsp;</p><h3 id='测试案例-1简单无向图'><span>测试案例 1：简单无向图</span></h3><ul><li><p><strong><span>顶点数和边数</span></strong><span>：3个顶点，3条边</span></p></li><li><p><strong><span>顶点标号</span></strong><span>：A, B, C</span></p></li><li><p><span>边</span></p></li></ul><p><span>      ：</span></p><ul><li><p><span>(0, 1) 表示顶点A和顶点B之间有一条边</span></p></li><li><p><span>(1, 2) 表示顶点B和顶点C之间有一条边</span></p></li><li><p><span>(0, 2) 表示顶点A和顶点C之间有一条边</span></p></li></ul><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image038.jpg" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h3 id='测试案例-2包含环的无向图'><span>测试案例 2：包含环的无向图</span></h3><ul><li><p><strong><span>顶点数和边数</span></strong><span>：4个顶点，4条边</span></p></li><li><p><strong><span>顶点标号</span></strong><span>：A, B, C, D</span></p></li><li><p><span>边</span></p></li></ul><p><span>      ：</span></p><ul><li><p><span>(0, 1)</span></p></li><li><p><span>(1, 2)</span></p></li><li><p><span>(2, 3)</span></p></li><li><p><span>(3, 0)</span></p></li></ul><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image040.jpg" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h3 id='测试案例-3不连通的无向图'><span>测试案例 3：不连通的无向图</span></h3><ul><li><p><strong><span>顶点数和边数</span></strong><span>：5个顶点，3条边</span></p></li><li><p><strong><span>顶点标号</span></strong><span>：A, B, C, D, E</span></p></li><li><p><span>边</span></p></li></ul><p><span>      ：</span></p><ul><li><p><span>(0, 1)</span></p></li><li><p><span>(2, 3)</span></p></li><li><p><span>(3, 4)</span></p></li></ul><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image042.jpg" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h3 id='测试案例-4完全图'><span>测试案例 4：完全图</span></h3><ul><li><p><strong><span>顶点数和边数</span></strong><span>：4个顶点，6条边</span></p></li><li><p><strong><span>顶点标号</span></strong><span>：A, B, C, D</span></p></li><li><p><span>边</span></p></li></ul><p><span>      ：</span></p><ul><li><p><span>(0, 1)</span></p></li><li><p><span>(0, 2)</span></p></li><li><p><span>(0, 3)</span></p></li><li><p><span>(1, 2)</span></p></li><li><p><span>(1, 3)</span></p></li><li><p><span>(2, 3)</span></p></li></ul><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image044.jpg" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><h3 id='测试案例-5星形图'><span>测试案例 5：星形图</span></h3><ul><li><p><strong><span>顶点数和边数</span></strong><span>：5个顶点，4条边</span></p></li><li><p><strong><span>顶点标号</span></strong><span>：A, B, C, D, E</span></p></li><li><p><span>边</span></p></li></ul><p><span>      ：</span></p><ul><li><p><span>(0, 1)</span></p></li><li><p><span>(0, 2)</span></p></li><li><p><span>(0, 3)</span></p></li><li><p><span>(0, 4)</span></p></li></ul><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/oice_16_974fa576_32c1d314_3a3/AC/Temp/msohtmlclip1/01/clip_image046.jpg" referrerpolicy="no-referrer" alt="标题: fig:"></p><p>&nbsp;</p><p><span> </span></p></div></div>
</body>
</html>